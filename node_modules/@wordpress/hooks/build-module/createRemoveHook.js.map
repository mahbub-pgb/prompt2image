{
  "version": 3,
  "sources": ["../src/createRemoveHook.ts"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\nimport validateNamespace from './validateNamespace';\nimport validateHookName from './validateHookName';\nimport type { Hooks, StoreKey } from './types';\n\n/**\n * Removes the specified callback (or all callbacks) from the hook with a given hookName\n * and namespace.\n */\nexport type RemoveHook = (\n\t/**\n\t * The name of the hook to modify.\n\t */\n\thookName: string,\n\t/**\n\t * The unique namespace identifying the callback in the form `vendor/plugin/function`.\n\t */\n\tnamespace: string\n) => number | undefined;\n\n/**\n * Returns a function which, when invoked, will remove a specified hook or all\n * hooks by the given name.\n *\n * @param hooks             Hooks instance.\n * @param storeKey\n * @param [removeAll=false] Whether to remove all callbacks for a hookName,\n *                          without regard to namespace. Used to create\n *                          `removeAll*` functions.\n *\n * @return Function that removes hooks.\n */\nfunction createRemoveHook(\n\thooks: Hooks,\n\tstoreKey: StoreKey,\n\tremoveAll: boolean = false\n): RemoveHook {\n\treturn function removeHook( hookName, namespace ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\tif ( ! validateHookName( hookName ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! removeAll && ! validateNamespace( namespace ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Bail if no hooks exist by this name.\n\t\tif ( ! hooksStore[ hookName ] ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet handlersRemoved = 0;\n\n\t\tif ( removeAll ) {\n\t\t\thandlersRemoved = hooksStore[ hookName ].handlers.length;\n\t\t\thooksStore[ hookName ] = {\n\t\t\t\truns: hooksStore[ hookName ].runs,\n\t\t\t\thandlers: [],\n\t\t\t};\n\t\t} else {\n\t\t\t// Try to find the specified callback to remove.\n\t\t\tconst handlers = hooksStore[ hookName ].handlers;\n\t\t\tfor ( let i = handlers.length - 1; i >= 0; i-- ) {\n\t\t\t\tif ( handlers[ i ].namespace === namespace ) {\n\t\t\t\t\thandlers.splice( i, 1 );\n\t\t\t\t\thandlersRemoved++;\n\t\t\t\t\t// This callback may also be part of a hook that is\n\t\t\t\t\t// currently executing.  If the callback we're removing\n\t\t\t\t\t// comes after the current callback, there's no problem;\n\t\t\t\t\t// otherwise we need to decrease the execution index of any\n\t\t\t\t\t// other runs by 1 to account for the removed element.\n\t\t\t\t\thooksStore.__current.forEach( ( hookInfo ) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\thookInfo.name === hookName &&\n\t\t\t\t\t\t\thookInfo.currentIndex >= i\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\thookInfo.currentIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( hookName !== 'hookRemoved' ) {\n\t\t\thooks.doAction( 'hookRemoved', hookName, namespace );\n\t\t}\n\n\t\treturn handlersRemoved;\n\t};\n}\n\nexport default createRemoveHook;\n"],
  "mappings": "AAGA,OAAO,uBAAuB;AAC9B,OAAO,sBAAsB;AA8B7B,SAAS,iBACR,OACA,UACA,YAAqB,OACR;AACb,SAAO,SAAS,WAAY,UAAU,WAAY;AACjD,UAAM,aAAa,MAAO,QAAS;AAEnC,QAAK,CAAE,iBAAkB,QAAS,GAAI;AACrC;AAAA,IACD;AAEA,QAAK,CAAE,aAAa,CAAE,kBAAmB,SAAU,GAAI;AACtD;AAAA,IACD;AAGA,QAAK,CAAE,WAAY,QAAS,GAAI;AAC/B,aAAO;AAAA,IACR;AAEA,QAAI,kBAAkB;AAEtB,QAAK,WAAY;AAChB,wBAAkB,WAAY,QAAS,EAAE,SAAS;AAClD,iBAAY,QAAS,IAAI;AAAA,QACxB,MAAM,WAAY,QAAS,EAAE;AAAA,QAC7B,UAAU,CAAC;AAAA,MACZ;AAAA,IACD,OAAO;AAEN,YAAM,WAAW,WAAY,QAAS,EAAE;AACxC,eAAU,IAAI,SAAS,SAAS,GAAG,KAAK,GAAG,KAAM;AAChD,YAAK,SAAU,CAAE,EAAE,cAAc,WAAY;AAC5C,mBAAS,OAAQ,GAAG,CAAE;AACtB;AAMA,qBAAW,UAAU,QAAS,CAAE,aAAc;AAC7C,gBACC,SAAS,SAAS,YAClB,SAAS,gBAAgB,GACxB;AACD,uBAAS;AAAA,YACV;AAAA,UACD,CAAE;AAAA,QACH;AAAA,MACD;AAAA,IACD;AAEA,QAAK,aAAa,eAAgB;AACjC,YAAM,SAAU,eAAe,UAAU,SAAU;AAAA,IACpD;AAEA,WAAO;AAAA,EACR;AACD;AAEA,IAAO,2BAAQ;",
  "names": []
}
