{
  "version": 3,
  "sources": ["../src/createHasHook.ts"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\nimport type { Hooks, StoreKey } from './types';\n/**\n *\n * Returns whether any handlers are attached for the given hookName and optional namespace.\n */\nexport type HasHook = (\n\t/**\n\t * The name of the hook to check for.\n\t */\n\thookname: string,\n\t/**\n\t * The unique namespace identifying the callback in the form `vendor/plugin/function`.\n\t */\n\tnamespace?: string\n) => boolean;\n\n/**\n * Returns a function which, when invoked, will return whether any handlers are\n * attached to a particular hook.\n *\n * @param hooks    Hooks instance.\n * @param storeKey\n *\n * @return  Function that returns whether any handlers are\n *                   attached to a particular hook and optional namespace.\n */\nfunction createHasHook( hooks: Hooks, storeKey: StoreKey ): HasHook {\n\treturn function hasHook( hookName, namespace ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\t// Use the namespace if provided.\n\t\tif ( 'undefined' !== typeof namespace ) {\n\t\t\treturn (\n\t\t\t\thookName in hooksStore &&\n\t\t\t\thooksStore[ hookName ].handlers.some(\n\t\t\t\t\t( hook ) => hook.namespace === namespace\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn hookName in hooksStore;\n\t};\n}\n\nexport default createHasHook;\n"],
  "mappings": "AA6BA,SAAS,cAAe,OAAc,UAA8B;AACnE,SAAO,SAAS,QAAS,UAAU,WAAY;AAC9C,UAAM,aAAa,MAAO,QAAS;AAGnC,QAAK,gBAAgB,OAAO,WAAY;AACvC,aACC,YAAY,cACZ,WAAY,QAAS,EAAE,SAAS;AAAA,QAC/B,CAAE,SAAU,KAAK,cAAc;AAAA,MAChC;AAAA,IAEF;AAEA,WAAO,YAAY;AAAA,EACpB;AACD;AAEA,IAAO,wBAAQ;",
  "names": []
}
