{
  "version": 3,
  "sources": ["../src/to-dom.js"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\nimport { createElement } from './create-element';\nimport { isRangeEqual } from './is-range-equal';\n\n/**\n * MathML namespace URI.\n *\n * @see https://www.w3.org/1998/Math/MathML/\n */\nconst MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\nfunction append( element, child ) {\n\tif ( child.html !== undefined ) {\n\t\treturn ( element.innerHTML += child.html );\n\t}\n\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tif ( type === '#comment' ) {\n\t\t\tchild = element.ownerDocument.createComment(\n\t\t\t\tattributes[ 'data-rich-text-comment' ]\n\t\t\t);\n\t\t} else {\n\t\t\t// Handle namespace-aware element creation\n\t\t\tconst parentNamespace = element.namespaceURI;\n\n\t\t\tif ( type === 'math' ) {\n\t\t\t\t// Root math element always uses MathML namespace\n\t\t\t\tchild = element.ownerDocument.createElementNS(\n\t\t\t\t\tMATHML_NAMESPACE,\n\t\t\t\t\ttype\n\t\t\t\t);\n\t\t\t} else if ( parentNamespace === MATHML_NAMESPACE ) {\n\t\t\t\tif ( element.tagName === 'MTEXT' ) {\n\t\t\t\t\t// mtext switches back to HTML namespace for phrasing content\n\t\t\t\t\tchild = element.ownerDocument.createElement( type );\n\t\t\t\t} else {\n\t\t\t\t\t// All other elements in MathML context use MathML namespace\n\t\t\t\t\tchild = element.ownerDocument.createElementNS(\n\t\t\t\t\t\tMATHML_NAMESPACE,\n\t\t\t\t\t\ttype\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Default HTML element creation\n\t\t\t\tchild = element.ownerDocument.createElement( type );\n\t\t\t}\n\n\t\t\tfor ( const key in attributes ) {\n\t\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( node ) {\n\treturn node.nodeType === node.TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nexport function toDom( {\n\tvalue,\n\tprepareEditableTree,\n\tisEditableTree = true,\n\tplaceholder,\n\tdoc = document,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tif ( prepareEditableTree ) {\n\t\tvalue = {\n\t\t\t...value,\n\t\t\tformats: prepareEditableTree( value ),\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new instance of a DOM tree upon which RichText operations can be\n\t * applied.\n\t *\n\t * Note: The current implementation will return a shared reference, reset on\n\t * each call to `createEmpty`. Therefore, you should not hold a reference to\n\t * the value to operate upon asynchronously, as it may have unexpected results.\n\t *\n\t * @return {Object} RichText tree.\n\t */\n\tconst createEmpty = () => createElement( doc, '' );\n\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tisEditableTree,\n\t\tplaceholder,\n\t} );\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`.\n *\n * @param {Object}        $1                       Named arguments.\n * @param {RichTextValue} $1.value                 Value to apply.\n * @param {HTMLElement}   $1.current               The live root node to apply the element tree to.\n * @param {Function}      [$1.prepareEditableTree] Function to filter editorable formats.\n * @param {boolean}       [$1.__unstableDomOnly]   Only apply elements, no selection.\n * @param {string}        [$1.placeholder]         Placeholder text.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tprepareEditableTree,\n\t__unstableDomOnly,\n\tplaceholder,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tprepareEditableTree,\n\t\tplaceholder,\n\t\tdoc: current.ownerDocument,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined && ! __unstableDomOnly ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\tlet futureChild;\n\n\twhile ( ( futureChild = future.firstChild ) ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( futureChild );\n\t\t} else if ( ! currentChild.isEqualNode( futureChild ) ) {\n\t\t\tif (\n\t\t\t\tcurrentChild.nodeName !== futureChild.nodeName ||\n\t\t\t\t( currentChild.nodeType === currentChild.TEXT_NODE &&\n\t\t\t\t\tcurrentChild.data !== futureChild.data )\n\t\t\t) {\n\t\t\t\tcurrent.replaceChild( futureChild, currentChild );\n\t\t\t} else {\n\t\t\t\tconst currentAttributes = currentChild.attributes;\n\t\t\t\tconst futureAttributes = futureChild.attributes;\n\n\t\t\t\tif ( currentAttributes ) {\n\t\t\t\t\tlet ii = currentAttributes.length;\n\n\t\t\t\t\t// Reverse loop because `removeAttribute` on `currentChild`\n\t\t\t\t\t// changes `currentAttributes`.\n\t\t\t\t\twhile ( ii-- ) {\n\t\t\t\t\t\tconst { name } = currentAttributes[ ii ];\n\n\t\t\t\t\t\tif ( ! futureChild.getAttribute( name ) ) {\n\t\t\t\t\t\t\tcurrentChild.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( futureAttributes ) {\n\t\t\t\t\tfor ( let ii = 0; ii < futureAttributes.length; ii++ ) {\n\t\t\t\t\t\tconst { name, value } = futureAttributes[ ii ];\n\n\t\t\t\t\t\tif ( currentChild.getAttribute( name ) !== value ) {\n\t\t\t\t\t\t\tcurrentChild.setAttribute( name, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tapplyValue( futureChild, currentChild );\n\t\t\t\tfuture.removeChild( futureChild );\n\t\t\t}\n\t\t} else {\n\t\t\tfuture.removeChild( futureChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\nexport function applySelection( { startPath, endPath }, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tstartPath\n\t);\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tendPath\n\t);\n\tconst { ownerDocument } = current;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\tconst range = ownerDocument.createRange();\n\n\trange.setStart( startContainer, startOffset );\n\trange.setEnd( endContainer, endOffset );\n\n\tconst { activeElement } = ownerDocument;\n\n\tif ( selection.rangeCount > 0 ) {\n\t\t// If the to be added range and the live range are the same, there's no\n\t\t// need to remove the live range and add the equivalent range.\n\t\tif ( isRangeEqual( range, selection.getRangeAt( 0 ) ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tselection.removeAllRanges();\n\t}\n\n\tselection.addRange( range );\n\n\t// This function is not intended to cause a shift in focus. Since the above\n\t// selection manipulations may shift focus, ensure that focus is restored to\n\t// its previous state.\n\tif ( activeElement !== ownerDocument.activeElement ) {\n\t\t// The `instanceof` checks protect against edge cases where the focused\n\t\t// element is not of the interface HTMLElement (does not have a `focus`\n\t\t// or `blur` property).\n\t\t//\n\t\t// See: https://github.com/Microsoft/TypeScript/issues/5901#issuecomment-431649653\n\t\tif ( activeElement instanceof defaultView.HTMLElement ) {\n\t\t\tactiveElement.focus();\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
