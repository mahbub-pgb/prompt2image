{
  "version": 3,
  "sources": ["../src/create.js"],
  "sourcesContent": ["/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { store as richTextStore } from './store';\nimport { createElement } from './create-element';\nimport { mergePair } from './concat';\nimport { OBJECT_REPLACEMENT_CHARACTER, ZWNBSP } from './special-characters';\nimport { toHTMLString } from './to-html-string';\nimport { getTextContent } from './get-text-content';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\nfunction createEmptyValue() {\n\treturn {\n\t\tformats: [],\n\t\treplacements: [],\n\t\ttext: '',\n\t};\n}\n\nfunction toFormat( { tagName, attributes } ) {\n\tlet formatType;\n\n\tif ( attributes && attributes.class ) {\n\t\tformatType = select( richTextStore ).getFormatTypeForClassName(\n\t\t\tattributes.class\n\t\t);\n\n\t\tif ( formatType ) {\n\t\t\t// Preserve any additional classes.\n\t\t\tattributes.class = ` ${ attributes.class } `\n\t\t\t\t.replace( ` ${ formatType.className } `, ' ' )\n\t\t\t\t.trim();\n\n\t\t\tif ( ! attributes.class ) {\n\t\t\t\tdelete attributes.class;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( ! formatType ) {\n\t\tformatType =\n\t\t\tselect( richTextStore ).getFormatTypeForBareElement( tagName );\n\t}\n\n\tif ( ! formatType ) {\n\t\treturn attributes ? { type: tagName, attributes } : { type: tagName };\n\t}\n\n\tif (\n\t\tformatType.__experimentalCreatePrepareEditableTree &&\n\t\t! formatType.__experimentalCreateOnChangeEditableValue\n\t) {\n\t\treturn null;\n\t}\n\n\tif ( ! attributes ) {\n\t\treturn { formatType, type: formatType.name, tagName };\n\t}\n\n\tconst registeredAttributes = {};\n\tconst unregisteredAttributes = {};\n\tconst _attributes = { ...attributes };\n\n\tfor ( const key in formatType.attributes ) {\n\t\tconst name = formatType.attributes[ key ];\n\n\t\tregisteredAttributes[ key ] = _attributes[ name ];\n\n\t\t// delete the attribute and what's left is considered\n\t\t// to be unregistered.\n\t\tdelete _attributes[ name ];\n\n\t\tif ( typeof registeredAttributes[ key ] === 'undefined' ) {\n\t\t\tdelete registeredAttributes[ key ];\n\t\t}\n\t}\n\n\tfor ( const name in _attributes ) {\n\t\tunregisteredAttributes[ name ] = attributes[ name ];\n\t}\n\n\tif ( formatType.contentEditable === false ) {\n\t\tdelete unregisteredAttributes.contenteditable;\n\t}\n\n\treturn {\n\t\tformatType,\n\t\ttype: formatType.name,\n\t\ttagName,\n\t\tattributes: registeredAttributes,\n\t\tunregisteredAttributes,\n\t};\n}\n\n/**\n * The RichTextData class is used to instantiate a wrapper around rich text\n * values, with methods that can be used to transform or manipulate the data.\n *\n * - Create an empty instance: `new RichTextData()`.\n * - Create one from an HTML string: `RichTextData.fromHTMLString(\n *   '<em>hello</em>' )`.\n * - Create one from a wrapper HTMLElement: `RichTextData.fromHTMLElement(\n *   document.querySelector( 'p' ) )`.\n * - Create one from plain text: `RichTextData.fromPlainText( '1\\n2' )`.\n * - Create one from a rich text value: `new RichTextData( { text: '...',\n *   formats: [ ... ] } )`.\n *\n * @todo Add methods to manipulate the data, such as applyFormat, slice etc.\n */\nexport class RichTextData {\n\t#value;\n\n\tstatic empty() {\n\t\treturn new RichTextData();\n\t}\n\tstatic fromPlainText( text ) {\n\t\treturn new RichTextData( create( { text } ) );\n\t}\n\tstatic fromHTMLString( html ) {\n\t\treturn new RichTextData( create( { html } ) );\n\t}\n\t/**\n\t * Create a RichTextData instance from an HTML element.\n\t *\n\t * @param {HTMLElement}                    htmlElement The HTML element to create the instance from.\n\t * @param {{preserveWhiteSpace?: boolean}} options     Options.\n\t * @return {RichTextData} The RichTextData instance.\n\t */\n\tstatic fromHTMLElement( htmlElement, options = {} ) {\n\t\tconst { preserveWhiteSpace = false } = options;\n\t\tconst element = preserveWhiteSpace\n\t\t\t? htmlElement\n\t\t\t: collapseWhiteSpace( htmlElement );\n\t\tconst richTextData = new RichTextData( create( { element } ) );\n\t\tObject.defineProperty( richTextData, 'originalHTML', {\n\t\t\tvalue: htmlElement.innerHTML,\n\t\t} );\n\t\treturn richTextData;\n\t}\n\tconstructor( init = createEmptyValue() ) {\n\t\tthis.#value = init;\n\t}\n\ttoPlainText() {\n\t\treturn getTextContent( this.#value );\n\t}\n\t// We could expose `toHTMLElement` at some point as well, but we'd only use\n\t// it internally.\n\t/**\n\t * Convert the rich text value to an HTML string.\n\t *\n\t * @param {{preserveWhiteSpace?: boolean}} options Options.\n\t * @return {string} The HTML string.\n\t */\n\ttoHTMLString( { preserveWhiteSpace } = {} ) {\n\t\treturn (\n\t\t\tthis.originalHTML ||\n\t\t\ttoHTMLString( { value: this.#value, preserveWhiteSpace } )\n\t\t);\n\t}\n\tvalueOf() {\n\t\treturn this.toHTMLString();\n\t}\n\ttoString() {\n\t\treturn this.toHTMLString();\n\t}\n\ttoJSON() {\n\t\treturn this.toHTMLString();\n\t}\n\tget length() {\n\t\treturn this.text.length;\n\t}\n\tget formats() {\n\t\treturn this.#value.formats;\n\t}\n\tget replacements() {\n\t\treturn this.#value.replacements;\n\t}\n\tget text() {\n\t\treturn this.#value.text;\n\t}\n}\n\nfor ( const name of Object.getOwnPropertyNames( String.prototype ) ) {\n\tif ( RichTextData.prototype.hasOwnProperty( name ) ) {\n\t\tcontinue;\n\t}\n\n\tObject.defineProperty( RichTextData.prototype, name, {\n\t\tvalue( ...args ) {\n\t\t\t// Should we convert back to RichTextData?\n\t\t\treturn this.toHTMLString()[ name ]( ...args );\n\t\t},\n\t} );\n}\n\n/**\n * Create a RichText value from an `Element` tree (DOM), an HTML string or a\n * plain text string, with optionally a `Range` object to set the selection. If\n * called without any input, an empty value will be created. The optional\n * functions can be used to filter out content.\n *\n * A value will have the following shape, which you are strongly encouraged not\n * to modify without the use of helper functions:\n *\n * ```js\n * {\n *   text: string,\n *   formats: Array,\n *   replacements: Array,\n *   ?start: number,\n *   ?end: number,\n * }\n * ```\n *\n * As you can see, text and formatting are separated. `text` holds the text,\n * including any replacement characters for objects and lines. `formats`,\n * `objects` and `lines` are all sparse arrays of the same length as `text`. It\n * holds information about the formatting at the relevant text indices. Finally\n * `start` and `end` state which text indices are selected. They are only\n * provided if a `Range` was given.\n *\n * @param {Object}  [$1]                          Optional named arguments.\n * @param {Element} [$1.element]                  Element to create value from.\n * @param {string}  [$1.text]                     Text to create value from.\n * @param {string}  [$1.html]                     HTML to create value from.\n * @param {Range}   [$1.range]                    Range to create value from.\n * @param {boolean} [$1.__unstableIsEditableTree]\n * @return {RichTextValue} A rich text value.\n */\nexport function create( {\n\telement,\n\ttext,\n\thtml,\n\trange,\n\t__unstableIsEditableTree: isEditableTree,\n} = {} ) {\n\tif ( html instanceof RichTextData ) {\n\t\treturn {\n\t\t\ttext: html.text,\n\t\t\tformats: html.formats,\n\t\t\treplacements: html.replacements,\n\t\t};\n\t}\n\n\tif ( typeof text === 'string' && text.length > 0 ) {\n\t\treturn {\n\t\t\tformats: Array( text.length ),\n\t\t\treplacements: Array( text.length ),\n\t\t\ttext,\n\t\t};\n\t}\n\n\tif ( typeof html === 'string' && html.length > 0 ) {\n\t\t// It does not matter which document this is, we're just using it to\n\t\t// parse.\n\t\telement = createElement( document, html );\n\t}\n\n\tif ( typeof element !== 'object' ) {\n\t\treturn createEmptyValue();\n\t}\n\n\treturn createFromElement( {\n\t\telement,\n\t\trange,\n\t\tisEditableTree,\n\t} );\n}\n\n/**\n * Helper to accumulate the value's selection start and end from the current\n * node and range.\n *\n * @param {Object} accumulator Object to accumulate into.\n * @param {Node}   node        Node to create value with.\n * @param {Range}  range       Range to create value with.\n * @param {Object} value       Value that is being accumulated.\n */\nfunction accumulateSelection( accumulator, node, range, value ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { parentNode } = node;\n\tconst { startContainer, startOffset, endContainer, endOffset } = range;\n\tconst currentLength = accumulator.text.length;\n\n\t// Selection can be extracted from value.\n\tif ( value.start !== undefined ) {\n\t\taccumulator.start = currentLength + value.start;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === startContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.start = currentLength + startOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset ]\n\t) {\n\t\taccumulator.start = currentLength;\n\t\t// Range indicates that the selection is after the current node.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset - 1 ]\n\t) {\n\t\taccumulator.start = currentLength + value.text.length;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === startContainer ) {\n\t\taccumulator.start = currentLength;\n\t}\n\n\t// Selection can be extracted from value.\n\tif ( value.end !== undefined ) {\n\t\taccumulator.end = currentLength + value.end;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === endContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset - 1 ]\n\t) {\n\t\taccumulator.end = currentLength + value.text.length;\n\t\t// Range indicates that the selection is before the current node.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset ]\n\t) {\n\t\taccumulator.end = currentLength;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === endContainer ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t}\n}\n\n/**\n * Adjusts the start and end offsets from a range based on a text filter.\n *\n * @param {Node}     node   Node of which the text should be filtered.\n * @param {Range}    range  The range to filter.\n * @param {Function} filter Function to use to filter the text.\n *\n * @return {Object|void} Object containing range properties.\n */\nfunction filterRange( node, range, filter ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { startContainer, endContainer } = range;\n\tlet { startOffset, endOffset } = range;\n\n\tif ( node === startContainer ) {\n\t\tstartOffset = filter( node.nodeValue.slice( 0, startOffset ) ).length;\n\t}\n\n\tif ( node === endContainer ) {\n\t\tendOffset = filter( node.nodeValue.slice( 0, endOffset ) ).length;\n\t}\n\n\treturn { startContainer, startOffset, endContainer, endOffset };\n}\n\n/**\n * Collapse any whitespace used for HTML formatting to one space character,\n * because it will also be displayed as such by the browser.\n *\n * We need to strip it from the content because we use white-space: pre-wrap for\n * displaying editable rich text. Without using white-space: pre-wrap, the\n * browser will litter the content with non breaking spaces, among other issues.\n * See packages/rich-text/src/component/use-default-style.js.\n *\n * @see\n * https://developer.mozilla.org/en-US/docs/Web/CSS/white-space-collapse#collapsing_of_white_space\n *\n * @param {HTMLElement} element\n * @param {boolean}     isRoot\n *\n * @return {HTMLElement} New element with collapsed whitespace.\n */\nfunction collapseWhiteSpace( element, isRoot = true ) {\n\tconst clone = element.cloneNode( true );\n\tclone.normalize();\n\tArray.from( clone.childNodes ).forEach( ( node, i, nodes ) => {\n\t\tif ( node.nodeType === node.TEXT_NODE ) {\n\t\t\tlet newNodeValue = node.nodeValue;\n\n\t\t\tif ( /[\\n\\t\\r\\f]/.test( newNodeValue ) ) {\n\t\t\t\tnewNodeValue = newNodeValue.replace( /[\\n\\t\\r\\f]+/g, ' ' );\n\t\t\t}\n\n\t\t\tif ( newNodeValue.indexOf( '  ' ) !== -1 ) {\n\t\t\t\tnewNodeValue = newNodeValue.replace( / {2,}/g, ' ' );\n\t\t\t}\n\n\t\t\tif ( i === 0 && newNodeValue.startsWith( ' ' ) ) {\n\t\t\t\tnewNodeValue = newNodeValue.slice( 1 );\n\t\t\t} else if (\n\t\t\t\tisRoot &&\n\t\t\t\ti === nodes.length - 1 &&\n\t\t\t\tnewNodeValue.endsWith( ' ' )\n\t\t\t) {\n\t\t\t\tnewNodeValue = newNodeValue.slice( 0, -1 );\n\t\t\t}\n\n\t\t\tnode.nodeValue = newNodeValue;\n\t\t} else if ( node.nodeType === node.ELEMENT_NODE ) {\n\t\t\tnode.replaceWith( collapseWhiteSpace( node, false ) );\n\t\t}\n\t} );\n\treturn clone;\n}\n\n/**\n * We need to normalise line breaks to `\\n` so they are consistent across\n * platforms and serialised properly. Not removing \\r would cause it to\n * linger and result in double line breaks when whitespace is preserved.\n */\nconst CARRIAGE_RETURN = '\\r';\n\n/**\n * Removes reserved characters used by rich-text (zero width non breaking spaces\n * added by `toTree` and object replacement characters).\n *\n * @param {string} string\n */\nexport function removeReservedCharacters( string ) {\n\t// with the global flag, note that we should create a new regex each time OR\n\t// reset lastIndex state.\n\treturn string.replace(\n\t\tnew RegExp(\n\t\t\t`[${ ZWNBSP }${ OBJECT_REPLACEMENT_CHARACTER }${ CARRIAGE_RETURN }]`,\n\t\t\t'gu'\n\t\t),\n\t\t''\n\t);\n}\n\n/**\n * Creates a Rich Text value from a DOM element and range.\n *\n * @param {Object}  $1                  Named arguments.\n * @param {Element} [$1.element]        Element to create value from.\n * @param {Range}   [$1.range]          Range to create value from.\n * @param {boolean} [$1.isEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nfunction createFromElement( { element, range, isEditableTree } ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element ) {\n\t\treturn accumulator;\n\t}\n\n\tif ( ! element.hasChildNodes() ) {\n\t\taccumulateSelection( accumulator, element, range, createEmptyValue() );\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.childNodes.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.childNodes[ index ];\n\t\tconst tagName = node.nodeName.toLowerCase();\n\n\t\tif ( node.nodeType === node.TEXT_NODE ) {\n\t\t\tconst text = removeReservedCharacters( node.nodeValue );\n\t\t\trange = filterRange( node, range, removeReservedCharacters );\n\t\t\taccumulateSelection( accumulator, node, range, { text } );\n\t\t\t// Create a sparse array of the same length as `text`, in which\n\t\t\t// formats can be added.\n\t\t\taccumulator.formats.length += text.length;\n\t\t\taccumulator.replacements.length += text.length;\n\t\t\taccumulator.text += text;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\tnode.nodeType === node.COMMENT_NODE ||\n\t\t\t( node.nodeType === node.ELEMENT_NODE &&\n\t\t\t\tnode.tagName === 'SPAN' &&\n\t\t\t\tnode.hasAttribute( 'data-rich-text-comment' ) )\n\t\t) {\n\t\t\tconst value = {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: '#comment',\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\t'data-rich-text-comment':\n\t\t\t\t\t\t\t\tnode.nodeType === node.COMMENT_NODE\n\t\t\t\t\t\t\t\t\t? node.nodeValue\n\t\t\t\t\t\t\t\t\t: node.getAttribute(\n\t\t\t\t\t\t\t\t\t\t\t'data-rich-text-comment'\n\t\t\t\t\t\t\t\t\t  ),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t};\n\t\t\taccumulateSelection( accumulator, node, range, value );\n\t\t\tmergePair( accumulator, value );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( node.nodeType !== node.ELEMENT_NODE ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\tisEditableTree &&\n\t\t\t// Ignore any line breaks that are not inserted by us.\n\t\t\ttagName === 'br' &&\n\t\t\t! node.getAttribute( 'data-rich-text-line-break' )\n\t\t) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( tagName === 'script' ) {\n\t\t\tconst value = {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: tagName,\n\t\t\t\t\t\tattributes: {\n\t\t\t\t\t\t\t'data-rich-text-script':\n\t\t\t\t\t\t\t\tnode.getAttribute( 'data-rich-text-script' ) ||\n\t\t\t\t\t\t\t\tencodeURIComponent( node.innerHTML ),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t};\n\t\t\taccumulateSelection( accumulator, node, range, value );\n\t\t\tmergePair( accumulator, value );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( tagName === 'br' ) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tmergePair( accumulator, create( { text: '\\n' } ) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst format = toFormat( {\n\t\t\ttagName,\n\t\t\tattributes: getAttributes( { element: node } ),\n\t\t} );\n\n\t\t// When a format type is declared as not editable, replace it with an\n\t\t// object replacement character and preserve the inner HTML.\n\t\tif ( format?.formatType?.contentEditable === false ) {\n\t\t\tdelete format.formatType;\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tmergePair( accumulator, {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements: [\n\t\t\t\t\t{\n\t\t\t\t\t\t...format,\n\t\t\t\t\t\tinnerHTML: node.innerHTML,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t} );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( format ) {\n\t\t\tdelete format.formatType;\n\t\t}\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tisEditableTree,\n\t\t} );\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\t// Ignore any placeholders, but keep their content since the browser\n\t\t// might insert text inside them when the editable element is flex.\n\t\tif (\n\t\t\t! format ||\n\t\t\tnode.getAttribute( 'data-rich-text-placeholder' ) ||\n\t\t\tnode.getAttribute( 'data-rich-text-bogus' )\n\t\t) {\n\t\t\tmergePair( accumulator, value );\n\t\t} else if ( value.text.length === 0 ) {\n\t\t\tif ( format.attributes ) {\n\t\t\t\tmergePair( accumulator, {\n\t\t\t\t\tformats: [ , ],\n\t\t\t\t\treplacements: [ format ],\n\t\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\t\t\t// Indices should share a reference to the same formats array.\n\t\t\t// Only create a new reference if `formats` changes.\n\t\t\tfunction mergeFormats( formats ) {\n\t\t\t\tif ( mergeFormats.formats === formats ) {\n\t\t\t\t\treturn mergeFormats.newFormats;\n\t\t\t\t}\n\n\t\t\t\tconst newFormats = formats\n\t\t\t\t\t? [ format, ...formats ]\n\t\t\t\t\t: [ format ];\n\n\t\t\t\tmergeFormats.formats = formats;\n\t\t\t\tmergeFormats.newFormats = newFormats;\n\n\t\t\t\treturn newFormats;\n\t\t\t}\n\n\t\t\t// Since the formats parameter can be `undefined`, preset\n\t\t\t// `mergeFormats` with a new reference.\n\t\t\tmergeFormats.newFormats = [ format ];\n\n\t\t\tmergePair( accumulator, {\n\t\t\t\t...value,\n\t\t\t\tformats: Array.from( value.formats, mergeFormats ),\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Gets the attributes of an element in object shape.\n *\n * @param {Object}  $1         Named arguments.\n * @param {Element} $1.element Element to get attributes from.\n *\n * @return {Object|void} Attribute object or `undefined` if the element has no\n *                       attributes.\n */\nfunction getAttributes( { element } ) {\n\tif ( ! element.hasAttributes() ) {\n\t\treturn;\n\t}\n\n\tconst length = element.attributes.length;\n\tlet accumulator;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst { name, value } = element.attributes[ i ];\n\n\t\tif ( name.indexOf( 'data-rich-text-' ) === 0 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst safeName = /^on/i.test( name )\n\t\t\t? 'data-disable-rich-text-' + name\n\t\t\t: name;\n\n\t\taccumulator = accumulator || {};\n\t\taccumulator[ safeName ] = value;\n\t}\n\n\treturn accumulator;\n}\n"],
  "mappings": "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",
  "names": ["value", "mergeFormats"]
}
