{
  "version": 3,
  "sources": ["../src/split.js"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Split a Rich Text value in two at the given `startIndex` and `endIndex`, or\n * split at the given separator. This is similar to `String.prototype.split`.\n * Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value\n * @param {number|string} [string] Start index, or string at which to split.\n *\n * @return {Array<RichTextValue>|undefined} An array of new values.\n */\nexport function split( { formats, replacements, text, start, end }, string ) {\n\tif ( typeof string !== 'string' ) {\n\t\treturn splitAtSelection( ...arguments );\n\t}\n\n\tlet nextStart = 0;\n\n\treturn text.split( string ).map( ( substring ) => {\n\t\tconst startIndex = nextStart;\n\t\tconst value = {\n\t\t\tformats: formats.slice( startIndex, startIndex + substring.length ),\n\t\t\treplacements: replacements.slice(\n\t\t\t\tstartIndex,\n\t\t\t\tstartIndex + substring.length\n\t\t\t),\n\t\t\ttext: substring,\n\t\t};\n\n\t\tnextStart += string.length + substring.length;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\t\t\tif ( start >= startIndex && start < nextStart ) {\n\t\t\t\tvalue.start = start - startIndex;\n\t\t\t} else if ( start < startIndex && end > startIndex ) {\n\t\t\t\tvalue.start = 0;\n\t\t\t}\n\n\t\t\tif ( end >= startIndex && end < nextStart ) {\n\t\t\t\tvalue.end = end - startIndex;\n\t\t\t} else if ( start < nextStart && end > nextStart ) {\n\t\t\t\tvalue.end = substring.length;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t} );\n}\n\nfunction splitAtSelection(\n\t{ formats, replacements, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\tconst before = {\n\t\tformats: formats.slice( 0, startIndex ),\n\t\treplacements: replacements.slice( 0, startIndex ),\n\t\ttext: text.slice( 0, startIndex ),\n\t};\n\tconst after = {\n\t\tformats: formats.slice( endIndex ),\n\t\treplacements: replacements.slice( endIndex ),\n\t\ttext: text.slice( endIndex ),\n\t\tstart: 0,\n\t\tend: 0,\n\t};\n\n\treturn [ before, after ];\n}\n"],
  "mappings": "AAgBO,SAAS,MAAO,EAAE,SAAS,cAAc,MAAM,OAAO,IAAI,GAAG,QAAS;AAC5E,MAAK,OAAO,WAAW,UAAW;AACjC,WAAO,iBAAkB,GAAG,SAAU;AAAA,EACvC;AAEA,MAAI,YAAY;AAEhB,SAAO,KAAK,MAAO,MAAO,EAAE,IAAK,CAAE,cAAe;AACjD,UAAM,aAAa;AACnB,UAAM,QAAQ;AAAA,MACb,SAAS,QAAQ,MAAO,YAAY,aAAa,UAAU,MAAO;AAAA,MAClE,cAAc,aAAa;AAAA,QAC1B;AAAA,QACA,aAAa,UAAU;AAAA,MACxB;AAAA,MACA,MAAM;AAAA,IACP;AAEA,iBAAa,OAAO,SAAS,UAAU;AAEvC,QAAK,UAAU,UAAa,QAAQ,QAAY;AAC/C,UAAK,SAAS,cAAc,QAAQ,WAAY;AAC/C,cAAM,QAAQ,QAAQ;AAAA,MACvB,WAAY,QAAQ,cAAc,MAAM,YAAa;AACpD,cAAM,QAAQ;AAAA,MACf;AAEA,UAAK,OAAO,cAAc,MAAM,WAAY;AAC3C,cAAM,MAAM,MAAM;AAAA,MACnB,WAAY,QAAQ,aAAa,MAAM,WAAY;AAClD,cAAM,MAAM,UAAU;AAAA,MACvB;AAAA,IACD;AAEA,WAAO;AAAA,EACR,CAAE;AACH;AAEA,SAAS,iBACR,EAAE,SAAS,cAAc,MAAM,OAAO,IAAI,GAC1C,aAAa,OACb,WAAW,KACV;AACD,MAAK,UAAU,UAAa,QAAQ,QAAY;AAC/C;AAAA,EACD;AAEA,QAAM,SAAS;AAAA,IACd,SAAS,QAAQ,MAAO,GAAG,UAAW;AAAA,IACtC,cAAc,aAAa,MAAO,GAAG,UAAW;AAAA,IAChD,MAAM,KAAK,MAAO,GAAG,UAAW;AAAA,EACjC;AACA,QAAM,QAAQ;AAAA,IACb,SAAS,QAAQ,MAAO,QAAS;AAAA,IACjC,cAAc,aAAa,MAAO,QAAS;AAAA,IAC3C,MAAM,KAAK,MAAO,QAAS;AAAA,IAC3B,OAAO;AAAA,IACP,KAAK;AAAA,EACN;AAEA,SAAO,CAAE,QAAQ,KAAM;AACxB;",
  "names": []
}
