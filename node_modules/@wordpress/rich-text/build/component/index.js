"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var component_exports = {};
__export(component_exports, {
  default: () => __experimentalRichText,
  useRichText: () => useRichText
});
module.exports = __toCommonJS(component_exports);
var import_element = require("@wordpress/element");
var import_compose = require("@wordpress/compose");
var import_data = require("@wordpress/data");
var import_create = require("../create");
var import_to_dom = require("../to-dom");
var import_to_html_string = require("../to-html-string");
var import_use_default_style = require("./use-default-style");
var import_use_boundary_style = require("./use-boundary-style");
var import_event_listeners = require("./event-listeners");
function useRichText({
  value = "",
  selectionStart,
  selectionEnd,
  placeholder,
  onSelectionChange,
  preserveWhiteSpace,
  onChange,
  __unstableDisableFormats: disableFormats,
  __unstableIsSelected: isSelected,
  __unstableDependencies = [],
  __unstableAfterParse,
  __unstableBeforeSerialize,
  __unstableAddInvisibleFormats
}) {
  const registry = (0, import_data.useRegistry)();
  const [, forceRender] = (0, import_element.useReducer)(() => ({}));
  const ref = (0, import_element.useRef)();
  function createRecord() {
    const {
      ownerDocument: { defaultView }
    } = ref.current;
    const selection = defaultView.getSelection();
    const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
    return (0, import_create.create)({
      element: ref.current,
      range,
      __unstableIsEditableTree: true
    });
  }
  function applyRecord(newRecord, { domOnly } = {}) {
    (0, import_to_dom.apply)({
      value: newRecord,
      current: ref.current,
      prepareEditableTree: __unstableAddInvisibleFormats,
      __unstableDomOnly: domOnly,
      placeholder
    });
  }
  const _valueRef = (0, import_element.useRef)(value);
  const recordRef = (0, import_element.useRef)();
  function setRecordFromProps() {
    _valueRef.current = value;
    recordRef.current = value;
    if (!(value instanceof import_create.RichTextData)) {
      recordRef.current = value ? import_create.RichTextData.fromHTMLString(value, { preserveWhiteSpace }) : import_create.RichTextData.empty();
    }
    recordRef.current = {
      text: recordRef.current.text,
      formats: recordRef.current.formats,
      replacements: recordRef.current.replacements
    };
    if (disableFormats) {
      recordRef.current.formats = Array(value.length);
      recordRef.current.replacements = Array(value.length);
    }
    if (__unstableAfterParse) {
      recordRef.current.formats = __unstableAfterParse(
        recordRef.current
      );
    }
    recordRef.current.start = selectionStart;
    recordRef.current.end = selectionEnd;
  }
  const hadSelectionUpdateRef = (0, import_element.useRef)(false);
  if (!recordRef.current) {
    hadSelectionUpdateRef.current = isSelected;
    setRecordFromProps();
  } else if (selectionStart !== recordRef.current.start || selectionEnd !== recordRef.current.end) {
    hadSelectionUpdateRef.current = isSelected;
    recordRef.current = {
      ...recordRef.current,
      start: selectionStart,
      end: selectionEnd,
      activeFormats: void 0
    };
  }
  function handleChange(newRecord) {
    recordRef.current = newRecord;
    applyRecord(newRecord);
    if (disableFormats) {
      _valueRef.current = newRecord.text;
    } else {
      const newFormats = __unstableBeforeSerialize ? __unstableBeforeSerialize(newRecord) : newRecord.formats;
      newRecord = { ...newRecord, formats: newFormats };
      if (typeof value === "string") {
        _valueRef.current = (0, import_to_html_string.toHTMLString)({
          value: newRecord,
          preserveWhiteSpace
        });
      } else {
        _valueRef.current = new import_create.RichTextData(newRecord);
      }
    }
    const { start, end, formats, text } = recordRef.current;
    registry.batch(() => {
      onSelectionChange(start, end);
      onChange(_valueRef.current, {
        __unstableFormats: formats,
        __unstableText: text
      });
    });
    forceRender();
  }
  function applyFromProps() {
    const previousValue = _valueRef.current;
    setRecordFromProps();
    const contentLengthChanged = previousValue && typeof previousValue === "string" && typeof value === "string" && previousValue.length !== value.length;
    const hasFocus = ref.current?.contains(
      ref.current.ownerDocument.activeElement
    );
    const skipSelection = contentLengthChanged && !hasFocus;
    applyRecord(recordRef.current, { domOnly: skipSelection });
  }
  const didMountRef = (0, import_element.useRef)(false);
  (0, import_element.useLayoutEffect)(() => {
    if (didMountRef.current && value !== _valueRef.current) {
      applyFromProps();
      forceRender();
    }
  }, [value]);
  (0, import_element.useLayoutEffect)(() => {
    if (!hadSelectionUpdateRef.current) {
      return;
    }
    if (ref.current.ownerDocument.activeElement !== ref.current) {
      ref.current.focus();
    }
    applyRecord(recordRef.current);
    hadSelectionUpdateRef.current = false;
  }, [hadSelectionUpdateRef.current]);
  const mergedRefs = (0, import_compose.useMergeRefs)([
    ref,
    (0, import_use_default_style.useDefaultStyle)(),
    (0, import_use_boundary_style.useBoundaryStyle)({ record: recordRef }),
    (0, import_event_listeners.useEventListeners)({
      record: recordRef,
      handleChange,
      applyRecord,
      createRecord,
      isSelected,
      onSelectionChange,
      forceRender
    }),
    (0, import_compose.useRefEffect)(() => {
      applyFromProps();
      didMountRef.current = true;
    }, [placeholder, ...__unstableDependencies])
  ]);
  return {
    value: recordRef.current,
    // A function to get the most recent value so event handlers in
    // useRichText implementations have access to it. For example when
    // listening to input events, we internally update the state, but this
    // state is not yet available to the input event handler because React
    // may re-render asynchronously.
    getValue: () => recordRef.current,
    onChange: handleChange,
    ref: mergedRefs
  };
}
function __experimentalRichText() {
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useRichText
});
//# sourceMappingURL=index.js.map
