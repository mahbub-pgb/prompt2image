{
  "version": 3,
  "sources": ["../src/to-tree.js"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\nimport { getFormatType } from './get-format-type';\nimport { OBJECT_REPLACEMENT_CHARACTER, ZWNBSP } from './special-characters';\n\nfunction restoreOnAttributes( attributes, isEditableTree ) {\n\tif ( isEditableTree ) {\n\t\treturn attributes;\n\t}\n\n\tconst newAttributes = {};\n\n\tfor ( const key in attributes ) {\n\t\tlet newKey = key;\n\t\tif ( key.startsWith( 'data-disable-rich-text-' ) ) {\n\t\t\tnewKey = key.slice( 'data-disable-rich-text-'.length );\n\t\t}\n\n\t\tnewAttributes[ newKey ] = attributes[ key ];\n\t}\n\n\treturn newAttributes;\n}\n\n/**\n * Converts a format object to information that can be used to create an element\n * from (type, attributes and object).\n *\n * @param {Object}  $1                        Named parameters.\n * @param {string}  $1.type                   The format type.\n * @param {string}  $1.tagName                The tag name.\n * @param {Object}  $1.attributes             The format attributes.\n * @param {Object}  $1.unregisteredAttributes The unregistered format\n *                                            attributes.\n * @param {boolean} $1.object                 Whether or not it is an object\n *                                            format.\n * @param {boolean} $1.boundaryClass          Whether or not to apply a boundary\n *                                            class.\n * @param {boolean} $1.isEditableTree\n *\n * @return {Object} Information to be used for element creation.\n */\nfunction fromFormat( {\n\ttype,\n\ttagName,\n\tattributes,\n\tunregisteredAttributes,\n\tobject,\n\tboundaryClass,\n\tisEditableTree,\n} ) {\n\tconst formatType = getFormatType( type );\n\n\tlet elementAttributes = {};\n\n\tif ( boundaryClass && isEditableTree ) {\n\t\telementAttributes[ 'data-rich-text-format-boundary' ] = 'true';\n\t}\n\n\tif ( ! formatType ) {\n\t\tif ( attributes ) {\n\t\t\telementAttributes = { ...attributes, ...elementAttributes };\n\t\t}\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tattributes: restoreOnAttributes(\n\t\t\t\telementAttributes,\n\t\t\t\tisEditableTree\n\t\t\t),\n\t\t\tobject,\n\t\t};\n\t}\n\n\telementAttributes = { ...unregisteredAttributes, ...elementAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes\n\t\t\t? formatType.attributes[ name ]\n\t\t\t: false;\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: tagName || formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: restoreOnAttributes( elementAttributes, isEditableTree ),\n\t};\n}\n\n/**\n * Checks if both arrays of formats up until a certain index are equal.\n *\n * @param {Array}  a     Array of formats to compare.\n * @param {Array}  b     Array of formats to compare.\n * @param {number} index Index to check until.\n */\nfunction isEqualUntil( a, b, index ) {\n\tdo {\n\t\tif ( a[ index ] !== b[ index ] ) {\n\t\t\treturn false;\n\t\t}\n\t} while ( index-- );\n\n\treturn true;\n}\n\nexport function toTree( {\n\tvalue,\n\tpreserveWhiteSpace,\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n\tplaceholder,\n} ) {\n\tconst { formats, replacements, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst activeFormats = getActiveFormats( value );\n\tconst deepestActiveFormat = activeFormats[ activeFormats.length - 1 ];\n\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\tappend( tree, '' );\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst shouldInsertPadding =\n\t\t\tisEditableTree &&\n\t\t\t// Pad the line if the line is empty.\n\t\t\t( ! lastCharacter ||\n\t\t\t\t// Pad the line if the previous character is a line break, otherwise\n\t\t\t\t// the line break won't be visible.\n\t\t\t\tlastCharacter === '\\n' );\n\n\t\tconst characterFormats = formats[ i ];\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\t// Reuse the last element if all formats remain the same.\n\t\t\t\t\tisEqualUntil(\n\t\t\t\t\t\tcharacterFormats,\n\t\t\t\t\t\tlastCharacterFormats,\n\t\t\t\t\t\tformatIndex\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, tagName, attributes, unregisteredAttributes } =\n\t\t\t\t\tformat;\n\n\t\t\t\tconst boundaryClass =\n\t\t\t\t\tisEditableTree && format === deepestActiveFormat;\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append(\n\t\t\t\t\tparent,\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\ttagName,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tunregisteredAttributes,\n\t\t\t\t\t\tboundaryClass,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character === OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tconst replacement = replacements[ i ];\n\t\t\tif ( ! replacement ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst { type, attributes, innerHTML } = replacement;\n\t\t\tconst formatType = getFormatType( type );\n\n\t\t\tif ( isEditableTree && type === '#comment' ) {\n\t\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\tcontenteditable: 'false',\n\t\t\t\t\t\t'data-rich-text-comment':\n\t\t\t\t\t\t\tattributes[ 'data-rich-text-comment' ],\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t\tappend(\n\t\t\t\t\tappend( pointer, { type: 'span' } ),\n\t\t\t\t\tattributes[ 'data-rich-text-comment' ].trim()\n\t\t\t\t);\n\t\t\t} else if ( ! isEditableTree && type === 'script' ) {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype: 'script',\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\tappend( pointer, {\n\t\t\t\t\thtml: decodeURIComponent(\n\t\t\t\t\t\tattributes[ 'data-rich-text-script' ]\n\t\t\t\t\t),\n\t\t\t\t} );\n\t\t\t} else if ( formatType?.contentEditable === false ) {\n\t\t\t\tpointer = getParent( pointer );\n\t\t\t\t// For non editable formats, render the stored inner HTML.\n\t\t\t\tif ( isEditableTree ) {\n\t\t\t\t\tconst attrs = {\n\t\t\t\t\t\tcontenteditable: 'false',\n\t\t\t\t\t\t'data-rich-text-bogus': true,\n\t\t\t\t\t};\n\t\t\t\t\tif ( start === i && end === i + 1 ) {\n\t\t\t\t\t\tattrs[ 'data-rich-text-format-boundary' ] = true;\n\t\t\t\t\t}\n\t\t\t\t\tpointer = append( pointer, {\n\t\t\t\t\t\ttype: 'span',\n\t\t\t\t\t\tattributes: attrs,\n\t\t\t\t\t} );\n\t\t\t\t\t// Some browsers like Safari and Firefox have issues placing\n\t\t\t\t\t// the caret after a non-editable element when it's at the\n\t\t\t\t\t// end of the field, so help them a little by providing a\n\t\t\t\t\t// text element. Similar to `insertPadding` above.\n\t\t\t\t\tif ( isEditableTree && i + 1 === text.length ) {\n\t\t\t\t\t\tappend( getParent( pointer ), ZWNBSP );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer = append(\n\t\t\t\t\tpointer,\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( innerHTML ) {\n\t\t\t\t\tappend( pointer, {\n\t\t\t\t\t\thtml: innerHTML,\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tobject: true,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! preserveWhiteSpace && character === '\\n' ) {\n\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\ttype: 'br',\n\t\t\t\tattributes: isEditableTree\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t'data-rich-text-line-break': 'true',\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined,\n\t\t\t\tobject: true,\n\t\t\t} );\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! isText( pointer ) ) {\n\t\t\tpointer = append( getParent( pointer ), character );\n\t\t} else {\n\t\t\tappendText( pointer, character );\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tif ( shouldInsertPadding && i === text.length ) {\n\t\t\tappend( getParent( pointer ), ZWNBSP );\n\n\t\t\t// We CANNOT use CSS to add a placeholder with pseudo elements on\n\t\t\t// the main block wrappers because that could clash with theme CSS.\n\t\t\tif ( placeholder && text.length === 0 ) {\n\t\t\t\tappend( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t'data-rich-text-placeholder': placeholder,\n\t\t\t\t\t\t// Necessary to prevent the placeholder from catching\n\t\t\t\t\t\t// selection and being editable.\n\t\t\t\t\t\tstyle: 'pointer-events:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;',\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n"],
  "mappings": "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",
  "names": []
}
