{
  "version": 3,
  "sources": ["../../src/redux-store/index.js"],
  "sourcesContent": ["/**\n * External dependencies\n */\nimport { createStore, applyMiddleware } from 'redux';\nimport EquivalentKeyMap from 'equivalent-key-map';\n\n/**\n * WordPress dependencies\n */\nimport createReduxRoutineMiddleware from '@wordpress/redux-routine';\nimport { compose } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { combineReducers } from './combine-reducers';\nimport { builtinControls } from '../controls';\nimport { lock } from '../lock-unlock';\nimport promise from '../promise-middleware';\nimport createResolversCacheMiddleware from '../resolvers-cache-middleware';\nimport createThunkMiddleware from './thunk-middleware';\nimport metadataReducer from './metadata/reducer';\nimport * as metadataSelectors from './metadata/selectors';\nimport * as metadataActions from './metadata/actions';\n\nexport { combineReducers };\n\n/** @typedef {import('../types').DataRegistry} DataRegistry */\n/** @typedef {import('../types').ListenerFunction} ListenerFunction */\n/**\n * @typedef {import('../types').StoreDescriptor<C>} StoreDescriptor\n * @template {import('../types').AnyConfig} C\n */\n/**\n * @typedef {import('../types').ReduxStoreConfig<State,Actions,Selectors>} ReduxStoreConfig\n * @template State\n * @template {Record<string,import('../types').ActionCreator>} Actions\n * @template Selectors\n */\n\nconst trimUndefinedValues = ( array ) => {\n\tconst result = [ ...array ];\n\tfor ( let i = result.length - 1; i >= 0; i-- ) {\n\t\tif ( result[ i ] === undefined ) {\n\t\t\tresult.splice( i, 1 );\n\t\t}\n\t}\n\treturn result;\n};\n\n/**\n * Creates a new object with the same keys, but with `callback()` called as\n * a transformer function on each of the values.\n *\n * @param {Object}   obj      The object to transform.\n * @param {Function} callback The function to transform each object value.\n * @return {Array} Transformed object.\n */\nconst mapValues = ( obj, callback ) =>\n\tObject.fromEntries(\n\t\tObject.entries( obj ?? {} ).map( ( [ key, value ] ) => [\n\t\t\tkey,\n\t\t\tcallback( value, key ),\n\t\t] )\n\t);\n\n// Convert  non serializable types to plain objects\nconst devToolsReplacer = ( key, state ) => {\n\tif ( state instanceof Map ) {\n\t\treturn Object.fromEntries( state );\n\t}\n\n\tif ( state instanceof window.HTMLElement ) {\n\t\treturn null;\n\t}\n\n\treturn state;\n};\n\n/**\n * Create a cache to track whether resolvers started running or not.\n *\n * @return {Object} Resolvers Cache.\n */\nfunction createResolversCache() {\n\tconst cache = {};\n\treturn {\n\t\tisRunning( selectorName, args ) {\n\t\t\treturn (\n\t\t\t\tcache[ selectorName ] &&\n\t\t\t\tcache[ selectorName ].get( trimUndefinedValues( args ) )\n\t\t\t);\n\t\t},\n\n\t\tclear( selectorName, args ) {\n\t\t\tif ( cache[ selectorName ] ) {\n\t\t\t\tcache[ selectorName ].delete( trimUndefinedValues( args ) );\n\t\t\t}\n\t\t},\n\n\t\tmarkAsRunning( selectorName, args ) {\n\t\t\tif ( ! cache[ selectorName ] ) {\n\t\t\t\tcache[ selectorName ] = new EquivalentKeyMap();\n\t\t\t}\n\n\t\t\tcache[ selectorName ].set( trimUndefinedValues( args ), true );\n\t\t},\n\t};\n}\n\nfunction createBindingCache( getItem, bindItem ) {\n\tconst cache = new WeakMap();\n\n\treturn {\n\t\tget( itemName ) {\n\t\t\tconst item = getItem( itemName );\n\t\t\tif ( ! item ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlet boundItem = cache.get( item );\n\t\t\tif ( ! boundItem ) {\n\t\t\t\tboundItem = bindItem( item, itemName );\n\t\t\t\tcache.set( item, boundItem );\n\t\t\t}\n\t\t\treturn boundItem;\n\t\t},\n\t};\n}\n\nfunction createPrivateProxy( publicItems, privateItems ) {\n\treturn new Proxy( publicItems, {\n\t\tget: ( target, itemName ) =>\n\t\t\tprivateItems.get( itemName ) || Reflect.get( target, itemName ),\n\t} );\n}\n\n/**\n * Creates a data store descriptor for the provided Redux store configuration containing\n * properties describing reducer, actions, selectors, controls and resolvers.\n *\n * @example\n * ```js\n * import { createReduxStore } from '@wordpress/data';\n *\n * const store = createReduxStore( 'demo', {\n *     reducer: ( state = 'OK' ) => state,\n *     selectors: {\n *         getValue: ( state ) => state,\n *     },\n * } );\n * ```\n *\n * @template State\n * @template {Record<string,import('../types').ActionCreator>} Actions\n * @template Selectors\n * @param {string}                                    key     Unique namespace identifier.\n * @param {ReduxStoreConfig<State,Actions,Selectors>} options Registered store options, with properties\n *                                                            describing reducer, actions, selectors,\n *                                                            and resolvers.\n *\n * @return   {StoreDescriptor<ReduxStoreConfig<State,Actions,Selectors>>} Store Object.\n */\nexport default function createReduxStore( key, options ) {\n\tconst privateActions = {};\n\tconst privateSelectors = {};\n\tconst privateRegistrationFunctions = {\n\t\tprivateActions,\n\t\tregisterPrivateActions: ( actions ) => {\n\t\t\tObject.assign( privateActions, actions );\n\t\t},\n\t\tprivateSelectors,\n\t\tregisterPrivateSelectors: ( selectors ) => {\n\t\t\tObject.assign( privateSelectors, selectors );\n\t\t},\n\t};\n\tconst storeDescriptor = {\n\t\tname: key,\n\t\tinstantiate: ( registry ) => {\n\t\t\t/**\n\t\t\t * Stores listener functions registered with `subscribe()`.\n\t\t\t *\n\t\t\t * When functions register to listen to store changes with\n\t\t\t * `subscribe()` they get added here. Although Redux offers\n\t\t\t * its own `subscribe()` function directly, by wrapping the\n\t\t\t * subscription in this store instance it's possible to\n\t\t\t * optimize checking if the state has changed before calling\n\t\t\t * each listener.\n\t\t\t *\n\t\t\t * @type {Set<ListenerFunction>}\n\t\t\t */\n\t\t\tconst listeners = new Set();\n\t\t\tconst reducer = options.reducer;\n\n\t\t\t// Object that every thunk function receives as the first argument. It contains the\n\t\t\t// `registry`, `dispatch`, `select` and `resolveSelect` fields. Some of them are\n\t\t\t// constructed as getters to avoid circular dependencies.\n\t\t\tconst thunkArgs = {\n\t\t\t\tregistry,\n\t\t\t\tget dispatch() {\n\t\t\t\t\treturn thunkDispatch;\n\t\t\t\t},\n\t\t\t\tget select() {\n\t\t\t\t\treturn thunkSelect;\n\t\t\t\t},\n\t\t\t\tget resolveSelect() {\n\t\t\t\t\treturn resolveSelectors;\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tconst store = instantiateReduxStore(\n\t\t\t\tkey,\n\t\t\t\toptions,\n\t\t\t\tregistry,\n\t\t\t\tthunkArgs\n\t\t\t);\n\n\t\t\t// Expose the private registration functions on the store\n\t\t\t// so they can be copied to a sub registry in registry.js.\n\t\t\tlock( store, privateRegistrationFunctions );\n\t\t\tconst resolversCache = createResolversCache();\n\n\t\t\t// Binds an action creator (`action`) to the `store`, making it a callable function.\n\t\t\t// These are the functions that are returned by `useDispatch`, for example.\n\t\t\t// It always returns a `Promise`, although actions are not always async. That's an\n\t\t\t// unfortunate backward compatibility measure.\n\t\t\tfunction bindAction( action ) {\n\t\t\t\treturn ( ...args ) =>\n\t\t\t\t\tPromise.resolve( store.dispatch( action( ...args ) ) );\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Object with all public actions, both metadata and store actions.\n\t\t\t */\n\t\t\tconst actions = {\n\t\t\t\t...mapValues( metadataActions, bindAction ),\n\t\t\t\t...mapValues( options.actions, bindAction ),\n\t\t\t};\n\n\t\t\t// Object with both public and private actions. Private actions are accessed through a proxy,\n\t\t\t// which looks them up in real time on the `privateActions` object. That's because private\n\t\t\t// actions can be registered at any time with `registerPrivateActions`. Also once a private\n\t\t\t// action creator is bound to the store, it is cached to give it a stable identity.\n\t\t\tconst allActions = createPrivateProxy(\n\t\t\t\tactions,\n\t\t\t\tcreateBindingCache(\n\t\t\t\t\t( name ) => privateActions[ name ],\n\t\t\t\t\tbindAction\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// An object that implements the `dispatch` object that is passed to thunk functions.\n\t\t\t// It is callable (`dispatch( action )`) and also has methods (`dispatch.foo()`) that\n\t\t\t// correspond to bound registered actions, both public and private. Implemented with the proxy\n\t\t\t// `get` method, delegating to `allActions`.\n\t\t\tconst thunkDispatch = new Proxy(\n\t\t\t\t( action ) => store.dispatch( action ),\n\t\t\t\t{ get: ( target, name ) => allActions[ name ] }\n\t\t\t);\n\n\t\t\t// To the public `actions` object, add the \"locked\" `allActions` object. When used,\n\t\t\t// `unlock( actions )` will return `allActions`, implementing a way how to get at the private actions.\n\t\t\tlock( actions, allActions );\n\n\t\t\t// If we have selector resolvers, convert them to a normalized form.\n\t\t\tconst resolvers = options.resolvers\n\t\t\t\t? mapValues( options.resolvers, mapResolver )\n\t\t\t\t: {};\n\n\t\t\t// Bind a selector to the store. Call the selector with the current state, correct registry,\n\t\t\t// and if there is a resolver, attach the resolver logic to the selector.\n\t\t\tfunction bindSelector( selector, selectorName ) {\n\t\t\t\tif ( selector.isRegistrySelector ) {\n\t\t\t\t\tselector.registry = registry;\n\t\t\t\t}\n\t\t\t\tconst boundSelector = ( ...args ) => {\n\t\t\t\t\targs = normalize( selector, args );\n\t\t\t\t\tconst state = store.__unstableOriginalGetState();\n\t\t\t\t\t// Before calling the selector, switch to the correct registry.\n\t\t\t\t\tif ( selector.isRegistrySelector ) {\n\t\t\t\t\t\tselector.registry = registry;\n\t\t\t\t\t}\n\t\t\t\t\treturn selector( state.root, ...args );\n\t\t\t\t};\n\n\t\t\t\t// Expose normalization method on the bound selector\n\t\t\t\t// in order that it can be called when fulfilling\n\t\t\t\t// the resolver.\n\t\t\t\tboundSelector.__unstableNormalizeArgs =\n\t\t\t\t\tselector.__unstableNormalizeArgs;\n\n\t\t\t\tconst resolver = resolvers[ selectorName ];\n\n\t\t\t\tif ( ! resolver ) {\n\t\t\t\t\tboundSelector.hasResolver = false;\n\t\t\t\t\treturn boundSelector;\n\t\t\t\t}\n\n\t\t\t\treturn mapSelectorWithResolver(\n\t\t\t\t\tboundSelector,\n\t\t\t\t\tselectorName,\n\t\t\t\t\tresolver,\n\t\t\t\t\tstore,\n\t\t\t\t\tresolversCache,\n\t\t\t\t\tboundMetadataSelectors\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Metadata selectors are bound differently: different state (`state.metadata`), no resolvers,\n\t\t\t// normalization depending on the target selector.\n\t\t\tfunction bindMetadataSelector( metaDataSelector ) {\n\t\t\t\tconst boundSelector = (\n\t\t\t\t\tselectorName,\n\t\t\t\t\tselectorArgs,\n\t\t\t\t\t...args\n\t\t\t\t) => {\n\t\t\t\t\t// Normalize the arguments passed to the target selector.\n\t\t\t\t\tif ( selectorName ) {\n\t\t\t\t\t\tconst targetSelector =\n\t\t\t\t\t\t\toptions.selectors?.[ selectorName ];\n\t\t\t\t\t\tif ( targetSelector ) {\n\t\t\t\t\t\t\tselectorArgs = normalize(\n\t\t\t\t\t\t\t\ttargetSelector,\n\t\t\t\t\t\t\t\tselectorArgs\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst state = store.__unstableOriginalGetState();\n\n\t\t\t\t\treturn metaDataSelector(\n\t\t\t\t\t\tstate.metadata,\n\t\t\t\t\t\tselectorName,\n\t\t\t\t\t\tselectorArgs,\n\t\t\t\t\t\t...args\n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\t\tboundSelector.hasResolver = false;\n\t\t\t\treturn boundSelector;\n\t\t\t}\n\n\t\t\t// Perform binding of both metadata and store selectors and combine them in one\n\t\t\t// `selectors` object. These are all public selectors of the store.\n\t\t\tconst boundMetadataSelectors = mapValues(\n\t\t\t\tmetadataSelectors,\n\t\t\t\tbindMetadataSelector\n\t\t\t);\n\n\t\t\tconst boundSelectors = mapValues( options.selectors, bindSelector );\n\n\t\t\tconst selectors = {\n\t\t\t\t...boundMetadataSelectors,\n\t\t\t\t...boundSelectors,\n\t\t\t};\n\n\t\t\t// Cache of bould private selectors. They are bound only when first accessed, because\n\t\t\t// new private selectors can be registered at any time (with `registerPrivateSelectors`).\n\t\t\t// Once bound, they are cached to give them a stable identity.\n\t\t\tconst boundPrivateSelectors = createBindingCache(\n\t\t\t\t( name ) => privateSelectors[ name ],\n\t\t\t\tbindSelector\n\t\t\t);\n\n\t\t\tconst allSelectors = createPrivateProxy(\n\t\t\t\tselectors,\n\t\t\t\tboundPrivateSelectors\n\t\t\t);\n\n\t\t\t// Pre-bind the private selectors that have been registered by the time of\n\t\t\t// instantiation, so that registry selectors are bound to the registry.\n\t\t\tfor ( const selectorName of Object.keys( privateSelectors ) ) {\n\t\t\t\tboundPrivateSelectors.get( selectorName );\n\t\t\t}\n\n\t\t\t// An object that implements the `select` object that is passed to thunk functions.\n\t\t\t// It is callable (`select( selector )`) and also has methods (`select.foo()`) that\n\t\t\t// correspond to bound registered selectors, both public and private. Implemented with the proxy\n\t\t\t// `get` method, delegating to `allSelectors`.\n\t\t\tconst thunkSelect = new Proxy(\n\t\t\t\t( selector ) => selector( store.__unstableOriginalGetState() ),\n\t\t\t\t{ get: ( target, name ) => allSelectors[ name ] }\n\t\t\t);\n\n\t\t\t// To the public `selectors` object, add the \"locked\" `allSelectors` object. When used,\n\t\t\t// `unlock( selectors )` will return `allSelectors`, implementing a way how to get at the private selectors.\n\t\t\tlock( selectors, allSelectors );\n\n\t\t\t// For each selector, create a function that calls the selector, waits for resolution and returns\n\t\t\t// a promise that resolves when the resolution is finished.\n\t\t\tconst bindResolveSelector = mapResolveSelector(\n\t\t\t\tstore,\n\t\t\t\tboundMetadataSelectors\n\t\t\t);\n\n\t\t\t// Now apply this function to all bound selectors, public and private. We are excluding\n\t\t\t// metadata selectors because they don't have resolvers.\n\t\t\tconst resolveSelectors = mapValues(\n\t\t\t\tboundSelectors,\n\t\t\t\tbindResolveSelector\n\t\t\t);\n\n\t\t\tconst allResolveSelectors = createPrivateProxy(\n\t\t\t\tresolveSelectors,\n\t\t\t\tcreateBindingCache(\n\t\t\t\t\t( name ) => boundPrivateSelectors.get( name ),\n\t\t\t\t\tbindResolveSelector\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// Lock the selectors so that `unlock( resolveSelectors )` returns `allResolveSelectors`.\n\t\t\tlock( resolveSelectors, allResolveSelectors );\n\n\t\t\t// Now, in a way very similar to `bindResolveSelector`, we create a function that maps\n\t\t\t// selectors to functions that throw a suspense promise if not yet resolved.\n\t\t\tconst bindSuspendSelector = mapSuspendSelector(\n\t\t\t\tstore,\n\t\t\t\tboundMetadataSelectors\n\t\t\t);\n\n\t\t\tconst suspendSelectors = {\n\t\t\t\t...boundMetadataSelectors, // no special suspense behavior\n\t\t\t\t...mapValues( boundSelectors, bindSuspendSelector ),\n\t\t\t};\n\n\t\t\tconst allSuspendSelectors = createPrivateProxy(\n\t\t\t\tsuspendSelectors,\n\t\t\t\tcreateBindingCache(\n\t\t\t\t\t( name ) => boundPrivateSelectors.get( name ),\n\t\t\t\t\tbindSuspendSelector\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// Lock the selectors so that `unlock( suspendSelectors )` returns 'allSuspendSelectors`.\n\t\t\tlock( suspendSelectors, allSuspendSelectors );\n\n\t\t\tconst getSelectors = () => selectors;\n\t\t\tconst getActions = () => actions;\n\t\t\tconst getResolveSelectors = () => resolveSelectors;\n\t\t\tconst getSuspendSelectors = () => suspendSelectors;\n\n\t\t\t// We have some modules monkey-patching the store object\n\t\t\t// It's wrong to do so but until we refactor all of our effects to controls\n\t\t\t// We need to keep the same \"store\" instance here.\n\t\t\tstore.__unstableOriginalGetState = store.getState;\n\t\t\tstore.getState = () => store.__unstableOriginalGetState().root;\n\n\t\t\t// Customize subscribe behavior to call listeners only on effective change,\n\t\t\t// not on every dispatch.\n\t\t\tconst subscribe =\n\t\t\t\tstore &&\n\t\t\t\t( ( listener ) => {\n\t\t\t\t\tlisteners.add( listener );\n\n\t\t\t\t\treturn () => listeners.delete( listener );\n\t\t\t\t} );\n\n\t\t\tlet lastState = store.__unstableOriginalGetState();\n\t\t\tstore.subscribe( () => {\n\t\t\t\tconst state = store.__unstableOriginalGetState();\n\t\t\t\tconst hasChanged = state !== lastState;\n\t\t\t\tlastState = state;\n\n\t\t\t\tif ( hasChanged ) {\n\t\t\t\t\tfor ( const listener of listeners ) {\n\t\t\t\t\t\tlistener();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// This can be simplified to just { subscribe, getSelectors, getActions }\n\t\t\t// Once we remove the use function.\n\t\t\treturn {\n\t\t\t\treducer,\n\t\t\t\tstore,\n\t\t\t\tactions,\n\t\t\t\tselectors,\n\t\t\t\tresolvers,\n\t\t\t\tgetSelectors,\n\t\t\t\tgetResolveSelectors,\n\t\t\t\tgetSuspendSelectors,\n\t\t\t\tgetActions,\n\t\t\t\tsubscribe,\n\t\t\t};\n\t\t},\n\t};\n\n\t// Expose the private registration functions on the store\n\t// descriptor. That's a natural choice since that's where the\n\t// public actions and selectors are stored.\n\tlock( storeDescriptor, privateRegistrationFunctions );\n\n\treturn storeDescriptor;\n}\n\n/**\n * Creates a redux store for a namespace.\n *\n * @param {string}       key       Unique namespace identifier.\n * @param {Object}       options   Registered store options, with properties\n *                                 describing reducer, actions, selectors,\n *                                 and resolvers.\n * @param {DataRegistry} registry  Registry reference.\n * @param {Object}       thunkArgs Argument object for the thunk middleware.\n * @return {Object} Newly created redux store.\n */\nfunction instantiateReduxStore( key, options, registry, thunkArgs ) {\n\tconst controls = {\n\t\t...options.controls,\n\t\t...builtinControls,\n\t};\n\n\tconst normalizedControls = mapValues( controls, ( control ) =>\n\t\tcontrol.isRegistryControl ? control( registry ) : control\n\t);\n\n\tconst middlewares = [\n\t\tcreateResolversCacheMiddleware( registry, key ),\n\t\tpromise,\n\t\tcreateReduxRoutineMiddleware( normalizedControls ),\n\t\tcreateThunkMiddleware( thunkArgs ),\n\t];\n\n\tconst enhancers = [ applyMiddleware( ...middlewares ) ];\n\tif (\n\t\ttypeof window !== 'undefined' &&\n\t\twindow.__REDUX_DEVTOOLS_EXTENSION__\n\t) {\n\t\tenhancers.push(\n\t\t\twindow.__REDUX_DEVTOOLS_EXTENSION__( {\n\t\t\t\tname: key,\n\t\t\t\tinstanceId: key,\n\t\t\t\tserialize: {\n\t\t\t\t\treplacer: devToolsReplacer,\n\t\t\t\t},\n\t\t\t} )\n\t\t);\n\t}\n\n\tconst { reducer, initialState } = options;\n\tconst enhancedReducer = combineReducers( {\n\t\tmetadata: metadataReducer,\n\t\troot: reducer,\n\t} );\n\n\treturn createStore(\n\t\tenhancedReducer,\n\t\t{ root: initialState },\n\t\tcompose( enhancers )\n\t);\n}\n\n/**\n * Maps selectors to functions that return a resolution promise for them.\n *\n * @param {Object} store                  The redux store the selectors are bound to.\n * @param {Object} boundMetadataSelectors The bound metadata selectors.\n *\n * @return {Function} Function that maps selectors to resolvers.\n */\nfunction mapResolveSelector( store, boundMetadataSelectors ) {\n\treturn ( selector, selectorName ) => {\n\t\t// If the selector doesn't have a resolver, just convert the return value\n\t\t// (including exceptions) to a Promise, no additional extra behavior is needed.\n\t\tif ( ! selector.hasResolver ) {\n\t\t\treturn async ( ...args ) => selector.apply( null, args );\n\t\t}\n\n\t\treturn ( ...args ) =>\n\t\t\tnew Promise( ( resolve, reject ) => {\n\t\t\t\tconst hasFinished = () => {\n\t\t\t\t\treturn boundMetadataSelectors.hasFinishedResolution(\n\t\t\t\t\t\tselectorName,\n\t\t\t\t\t\targs\n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\t\tconst finalize = ( result ) => {\n\t\t\t\t\tconst hasFailed =\n\t\t\t\t\t\tboundMetadataSelectors.hasResolutionFailed(\n\t\t\t\t\t\t\tselectorName,\n\t\t\t\t\t\t\targs\n\t\t\t\t\t\t);\n\t\t\t\t\tif ( hasFailed ) {\n\t\t\t\t\t\tconst error = boundMetadataSelectors.getResolutionError(\n\t\t\t\t\t\t\tselectorName,\n\t\t\t\t\t\t\targs\n\t\t\t\t\t\t);\n\t\t\t\t\t\treject( error );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve( result );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tconst getResult = () => selector.apply( null, args );\n\n\t\t\t\t// Trigger the selector (to trigger the resolver)\n\t\t\t\tconst result = getResult();\n\t\t\t\tif ( hasFinished() ) {\n\t\t\t\t\treturn finalize( result );\n\t\t\t\t}\n\n\t\t\t\tconst unsubscribe = store.subscribe( () => {\n\t\t\t\t\tif ( hasFinished() ) {\n\t\t\t\t\t\tunsubscribe();\n\t\t\t\t\t\tfinalize( getResult() );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t};\n}\n\n/**\n * Maps selectors to functions that throw a suspense promise if not yet resolved.\n *\n * @param {Object} store                  The redux store the selectors select from.\n * @param {Object} boundMetadataSelectors The bound metadata selectors.\n *\n * @return {Function} Function that maps selectors to their suspending versions.\n */\nfunction mapSuspendSelector( store, boundMetadataSelectors ) {\n\treturn ( selector, selectorName ) => {\n\t\t// Selector without a resolver doesn't have any extra suspense behavior.\n\t\tif ( ! selector.hasResolver ) {\n\t\t\treturn selector;\n\t\t}\n\n\t\treturn ( ...args ) => {\n\t\t\tconst result = selector.apply( null, args );\n\n\t\t\tif (\n\t\t\t\tboundMetadataSelectors.hasFinishedResolution(\n\t\t\t\t\tselectorName,\n\t\t\t\t\targs\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tif (\n\t\t\t\t\tboundMetadataSelectors.hasResolutionFailed(\n\t\t\t\t\t\tselectorName,\n\t\t\t\t\t\targs\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthrow boundMetadataSelectors.getResolutionError(\n\t\t\t\t\t\tselectorName,\n\t\t\t\t\t\targs\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tthrow new Promise( ( resolve ) => {\n\t\t\t\tconst unsubscribe = store.subscribe( () => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tboundMetadataSelectors.hasFinishedResolution(\n\t\t\t\t\t\t\tselectorName,\n\t\t\t\t\t\t\targs\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\tunsubscribe();\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t};\n\t};\n}\n\n/**\n * Convert a resolver to a normalized form, an object with `fulfill` method and\n * optional methods like `isFulfilled`.\n *\n * @param {Function} resolver Resolver to convert\n */\nfunction mapResolver( resolver ) {\n\tif ( resolver.fulfill ) {\n\t\treturn resolver;\n\t}\n\n\treturn {\n\t\t...resolver, // Copy the enumerable properties of the resolver function.\n\t\tfulfill: resolver, // Add the fulfill method.\n\t};\n}\n\n/**\n * Returns a selector with a matched resolver.\n * Resolvers are side effects invoked once per argument set of a given selector call,\n * used in ensuring that the data needs for the selector are satisfied.\n *\n * @param {Object} selector               The selector function to be bound.\n * @param {string} selectorName           The selector name.\n * @param {Object} resolver               Resolver to call.\n * @param {Object} store                  The redux store to which the resolvers should be mapped.\n * @param {Object} resolversCache         Resolvers Cache.\n * @param {Object} boundMetadataSelectors The bound metadata selectors.\n */\nfunction mapSelectorWithResolver(\n\tselector,\n\tselectorName,\n\tresolver,\n\tstore,\n\tresolversCache,\n\tboundMetadataSelectors\n) {\n\tfunction fulfillSelector( args ) {\n\t\tconst state = store.getState();\n\n\t\tif (\n\t\t\tresolversCache.isRunning( selectorName, args ) ||\n\t\t\t( typeof resolver.isFulfilled === 'function' &&\n\t\t\t\tresolver.isFulfilled( state, ...args ) )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tboundMetadataSelectors.hasStartedResolution( selectorName, args )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tresolversCache.markAsRunning( selectorName, args );\n\n\t\tsetTimeout( async () => {\n\t\t\tresolversCache.clear( selectorName, args );\n\t\t\tstore.dispatch(\n\t\t\t\tmetadataActions.startResolution( selectorName, args )\n\t\t\t);\n\t\t\ttry {\n\t\t\t\tconst action = resolver.fulfill( ...args );\n\t\t\t\tif ( action ) {\n\t\t\t\t\tawait store.dispatch( action );\n\t\t\t\t}\n\t\t\t\tstore.dispatch(\n\t\t\t\t\tmetadataActions.finishResolution( selectorName, args )\n\t\t\t\t);\n\t\t\t} catch ( error ) {\n\t\t\t\tstore.dispatch(\n\t\t\t\t\tmetadataActions.failResolution( selectorName, args, error )\n\t\t\t\t);\n\t\t\t}\n\t\t}, 0 );\n\t}\n\n\tconst selectorResolver = ( ...args ) => {\n\t\targs = normalize( selector, args );\n\t\tfulfillSelector( args );\n\t\treturn selector( ...args );\n\t};\n\tselectorResolver.hasResolver = true;\n\treturn selectorResolver;\n}\n\n/**\n * Applies selector's normalization function to the given arguments\n * if it exists.\n *\n * @param {Object} selector The selector potentially with a normalization method property.\n * @param {Array}  args     selector arguments to normalize.\n * @return {Array} Potentially normalized arguments.\n */\nfunction normalize( selector, args ) {\n\tif (\n\t\tselector.__unstableNormalizeArgs &&\n\t\ttypeof selector.__unstableNormalizeArgs === 'function' &&\n\t\targs?.length\n\t) {\n\t\treturn selector.__unstableNormalizeArgs( args );\n\t}\n\treturn args;\n}\n"],
  "mappings": "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",
  "names": ["EquivalentKeyMap", "createResolversCacheMiddleware", "promise", "createReduxRoutineMiddleware", "createThunkMiddleware", "metadataReducer", "result"]
}
