{
  "version": 3,
  "sources": ["../../src/dom/clean-node-list.js"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\nimport isEmpty from './is-empty';\nimport remove from './remove';\nimport unwrap from './unwrap';\nimport { isPhrasingContent } from '../phrasing-content';\nimport insertAfter from './insert-after';\nimport isElement from './is-element';\n\nconst noop = () => {};\n\n/* eslint-disable jsdoc/valid-types */\n/**\n * @typedef SchemaItem\n * @property {string[]}                            [attributes] Attributes.\n * @property {(string | RegExp)[]}                 [classes]    Classnames or RegExp to test against.\n * @property {'*' | { [tag: string]: SchemaItem }} [children]   Child schemas.\n * @property {string[]}                            [require]    Selectors to test required children against. Leave empty or undefined if there are no requirements.\n * @property {boolean}                             allowEmpty   Whether to allow nodes without children.\n * @property {(node: Node) => boolean}             [isMatch]    Function to test whether a node is a match. If left undefined any node will be assumed to match.\n */\n\n/** @typedef {{ [tag: string]: SchemaItem }} Schema */\n/* eslint-enable jsdoc/valid-types */\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on a node\n * list.\n *\n * @param {NodeList} nodeList The nodeList to filter.\n * @param {Document} doc      The document of the nodeList.\n * @param {Schema}   schema   An array of functions that can mutate with the provided node.\n * @param {boolean}  inline   Whether to clean for inline mode.\n */\nexport default function cleanNodeList( nodeList, doc, schema, inline ) {\n\tArray.from( nodeList ).forEach(\n\t\t( /** @type {Node & { nextElementSibling?: unknown }} */ node ) => {\n\t\t\tconst tag = node.nodeName.toLowerCase();\n\n\t\t\t// It's a valid child, if the tag exists in the schema without an isMatch\n\t\t\t// function, or with an isMatch function that matches the node.\n\t\t\tif (\n\t\t\t\tschema.hasOwnProperty( tag ) &&\n\t\t\t\t( ! schema[ tag ].isMatch || schema[ tag ].isMatch?.( node ) )\n\t\t\t) {\n\t\t\t\tif ( isElement( node ) ) {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tattributes = [],\n\t\t\t\t\t\tclasses = [],\n\t\t\t\t\t\tchildren,\n\t\t\t\t\t\trequire = [],\n\t\t\t\t\t\tallowEmpty,\n\t\t\t\t\t} = schema[ tag ];\n\n\t\t\t\t\t// If the node is empty and it's supposed to have children,\n\t\t\t\t\t// remove the node.\n\t\t\t\t\tif ( children && ! allowEmpty && isEmpty( node ) ) {\n\t\t\t\t\t\tremove( node );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( node.hasAttributes() ) {\n\t\t\t\t\t\t// Strip invalid attributes.\n\t\t\t\t\t\tArray.from( node.attributes ).forEach( ( { name } ) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tname !== 'class' &&\n\t\t\t\t\t\t\t\t! attributes.includes( name )\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tnode.removeAttribute( name );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// Strip invalid classes.\n\t\t\t\t\t\t// In jsdom-jscore, 'node.classList' can be undefined.\n\t\t\t\t\t\t// TODO: Explore patching this in jsdom-jscore.\n\t\t\t\t\t\tif ( node.classList && node.classList.length ) {\n\t\t\t\t\t\t\tconst mattchers = classes.map( ( item ) => {\n\t\t\t\t\t\t\t\tif ( item === '*' ) {\n\t\t\t\t\t\t\t\t\t// Keep all classes.\n\t\t\t\t\t\t\t\t\treturn () => true;\n\t\t\t\t\t\t\t\t} else if ( typeof item === 'string' ) {\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ className\n\t\t\t\t\t\t\t\t\t) => className === item;\n\t\t\t\t\t\t\t\t} else if ( item instanceof RegExp ) {\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ className\n\t\t\t\t\t\t\t\t\t) => item.test( className );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn noop;\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tArray.from( node.classList ).forEach( ( name ) => {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t! mattchers.some( ( isMatch ) =>\n\t\t\t\t\t\t\t\t\t\tisMatch( name )\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnode.classList.remove( name );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tif ( ! node.classList.length ) {\n\t\t\t\t\t\t\t\tnode.removeAttribute( 'class' );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( node.hasChildNodes() ) {\n\t\t\t\t\t\t// Do not filter any content.\n\t\t\t\t\t\tif ( children === '*' ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Continue if the node is supposed to have children.\n\t\t\t\t\t\tif ( children ) {\n\t\t\t\t\t\t\t// If a parent requires certain children, but it does\n\t\t\t\t\t\t\t// not have them, drop the parent and continue.\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\trequire.length &&\n\t\t\t\t\t\t\t\t! node.querySelector( require.join( ',' ) )\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t\t// If the node is at the top, phrasing content, and\n\t\t\t\t\t\t\t\t// contains children that are block content, unwrap\n\t\t\t\t\t\t\t\t// the node because it is invalid.\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\tnode.parentNode &&\n\t\t\t\t\t\t\t\tnode.parentNode.nodeName === 'BODY' &&\n\t\t\t\t\t\t\t\tisPhrasingContent( node )\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tArray.from( node.childNodes ).some(\n\t\t\t\t\t\t\t\t\t\t( child ) =>\n\t\t\t\t\t\t\t\t\t\t\t! isPhrasingContent( child )\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Remove children if the node is not supposed to have any.\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile ( node.firstChild ) {\n\t\t\t\t\t\t\t\tremove( node.firstChild );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Invalid child. Continue with schema at the same place and unwrap.\n\t\t\t} else {\n\t\t\t\tcleanNodeList( node.childNodes, doc, schema, inline );\n\n\t\t\t\t// For inline mode, insert a line break when unwrapping nodes that\n\t\t\t\t// are not phrasing content.\n\t\t\t\tif (\n\t\t\t\t\tinline &&\n\t\t\t\t\t! isPhrasingContent( node ) &&\n\t\t\t\t\tnode.nextElementSibling\n\t\t\t\t) {\n\t\t\t\t\tinsertAfter( doc.createElement( 'br' ), node );\n\t\t\t\t}\n\n\t\t\t\tunwrap( node );\n\t\t\t}\n\t\t}\n\t);\n}\n"],
  "mappings": "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",
  "names": ["isElement", "require", "isEmpty", "remove", "unwrap", "insertAfter"]
}
