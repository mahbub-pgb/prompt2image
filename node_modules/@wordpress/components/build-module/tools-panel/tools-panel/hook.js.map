{
  "version": 3,
  "sources": ["../../../src/tools-panel/tools-panel/hook.ts"],
  "sourcesContent": ["/**\n * WordPress dependencies\n */\nimport { useCallback, useEffect, useMemo, useReducer, useRef } from '@wordpress/element';\n\n/**\n * Internal dependencies\n */\nimport * as styles from '../styles';\nimport { useContextSystem } from '../../context';\nimport { useCx } from '../../utils/hooks/use-cx';\nconst DEFAULT_COLUMNS = 2;\nfunction emptyMenuItems() {\n  return {\n    default: {},\n    optional: {}\n  };\n}\nfunction emptyState() {\n  return {\n    panelItems: [],\n    menuItemOrder: [],\n    menuItems: emptyMenuItems()\n  };\n}\nconst generateMenuItems = ({\n  panelItems,\n  shouldReset,\n  currentMenuItems,\n  menuItemOrder\n}) => {\n  const newMenuItems = emptyMenuItems();\n  const menuItems = emptyMenuItems();\n  panelItems.forEach(({\n    hasValue,\n    isShownByDefault,\n    label\n  }) => {\n    const group = isShownByDefault ? 'default' : 'optional';\n\n    // If a menu item for this label has already been flagged as customized\n    // (for default controls), or toggled on (for optional controls), do not\n    // overwrite its value as those controls would lose that state.\n    const existingItemValue = currentMenuItems?.[group]?.[label];\n    const value = existingItemValue ? existingItemValue : hasValue();\n    newMenuItems[group][label] = shouldReset ? false : value;\n  });\n\n  // Loop the known, previously registered items first to maintain menu order.\n  menuItemOrder.forEach(key => {\n    if (newMenuItems.default.hasOwnProperty(key)) {\n      menuItems.default[key] = newMenuItems.default[key];\n    }\n    if (newMenuItems.optional.hasOwnProperty(key)) {\n      menuItems.optional[key] = newMenuItems.optional[key];\n    }\n  });\n\n  // Loop newMenuItems object adding any that aren't in the known items order.\n  Object.keys(newMenuItems.default).forEach(key => {\n    if (!menuItems.default.hasOwnProperty(key)) {\n      menuItems.default[key] = newMenuItems.default[key];\n    }\n  });\n  Object.keys(newMenuItems.optional).forEach(key => {\n    if (!menuItems.optional.hasOwnProperty(key)) {\n      menuItems.optional[key] = newMenuItems.optional[key];\n    }\n  });\n  return menuItems;\n};\nfunction panelItemsReducer(panelItems, action) {\n  switch (action.type) {\n    case 'REGISTER_PANEL':\n      {\n        const newItems = [...panelItems];\n        // If an item with this label has already been registered, remove it\n        // first. This can happen when an item is moved between the default\n        // and optional groups.\n        const existingIndex = newItems.findIndex(oldItem => oldItem.label === action.item.label);\n        if (existingIndex !== -1) {\n          newItems.splice(existingIndex, 1);\n        }\n        newItems.push(action.item);\n        return newItems;\n      }\n    case 'UNREGISTER_PANEL':\n      {\n        const index = panelItems.findIndex(item => item.label === action.label);\n        if (index !== -1) {\n          const newItems = [...panelItems];\n          newItems.splice(index, 1);\n          return newItems;\n        }\n        return panelItems;\n      }\n    default:\n      return panelItems;\n  }\n}\nfunction menuItemOrderReducer(menuItemOrder, action) {\n  switch (action.type) {\n    case 'REGISTER_PANEL':\n      {\n        // Track the initial order of item registration. This is used for\n        // maintaining menu item order later.\n        if (menuItemOrder.includes(action.item.label)) {\n          return menuItemOrder;\n        }\n        return [...menuItemOrder, action.item.label];\n      }\n    default:\n      return menuItemOrder;\n  }\n}\nfunction menuItemsReducer(state, action) {\n  switch (action.type) {\n    case 'REGISTER_PANEL':\n    case 'UNREGISTER_PANEL':\n      // generate new menu items from original `menuItems` and updated `panelItems` and `menuItemOrder`\n      return generateMenuItems({\n        currentMenuItems: state.menuItems,\n        panelItems: state.panelItems,\n        menuItemOrder: state.menuItemOrder,\n        shouldReset: false\n      });\n    case 'RESET_ALL':\n      return generateMenuItems({\n        panelItems: state.panelItems,\n        menuItemOrder: state.menuItemOrder,\n        shouldReset: true\n      });\n    case 'UPDATE_VALUE':\n      {\n        const oldValue = state.menuItems[action.group][action.label];\n        if (action.value === oldValue) {\n          return state.menuItems;\n        }\n        return {\n          ...state.menuItems,\n          [action.group]: {\n            ...state.menuItems[action.group],\n            [action.label]: action.value\n          }\n        };\n      }\n    case 'TOGGLE_VALUE':\n      {\n        const currentItem = state.panelItems.find(item => item.label === action.label);\n        if (!currentItem) {\n          return state.menuItems;\n        }\n        const menuGroup = currentItem.isShownByDefault ? 'default' : 'optional';\n        const newMenuItems = {\n          ...state.menuItems,\n          [menuGroup]: {\n            ...state.menuItems[menuGroup],\n            [action.label]: !state.menuItems[menuGroup][action.label]\n          }\n        };\n        return newMenuItems;\n      }\n    default:\n      return state.menuItems;\n  }\n}\nfunction panelReducer(state, action) {\n  const panelItems = panelItemsReducer(state.panelItems, action);\n  const menuItemOrder = menuItemOrderReducer(state.menuItemOrder, action);\n  // `menuItemsReducer` is a bit unusual because it generates new state from original `menuItems`\n  // and the updated `panelItems` and `menuItemOrder`.\n  const menuItems = menuItemsReducer({\n    panelItems,\n    menuItemOrder,\n    menuItems: state.menuItems\n  }, action);\n  return {\n    panelItems,\n    menuItemOrder,\n    menuItems\n  };\n}\nfunction resetAllFiltersReducer(filters, action) {\n  switch (action.type) {\n    case 'REGISTER':\n      return [...filters, action.filter];\n    case 'UNREGISTER':\n      return filters.filter(f => f !== action.filter);\n    default:\n      return filters;\n  }\n}\nconst isMenuItemTypeEmpty = obj => Object.keys(obj).length === 0;\nexport function useToolsPanel(props) {\n  const {\n    className,\n    headingLevel = 2,\n    resetAll,\n    panelId,\n    hasInnerWrapper = false,\n    shouldRenderPlaceholderItems = false,\n    __experimentalFirstVisibleItemClass,\n    __experimentalLastVisibleItemClass,\n    ...otherProps\n  } = useContextSystem(props, 'ToolsPanel');\n  const isResettingRef = useRef(false);\n  const wasResetting = isResettingRef.current;\n\n  // `isResettingRef` is cleared via this hook to effectively batch together\n  // the resetAll task. Without this, the flag is cleared after the first\n  // control updates and forces a rerender with subsequent controls then\n  // believing they need to reset, unfortunately using stale data.\n  useEffect(() => {\n    if (wasResetting) {\n      isResettingRef.current = false;\n    }\n  }, [wasResetting]);\n\n  // Allow panel items to register themselves.\n  const [{\n    panelItems,\n    menuItems\n  }, panelDispatch] = useReducer(panelReducer, undefined, emptyState);\n  const [resetAllFilters, dispatchResetAllFilters] = useReducer(resetAllFiltersReducer, []);\n  const registerPanelItem = useCallback(item => {\n    // Add item to panel items.\n    panelDispatch({\n      type: 'REGISTER_PANEL',\n      item\n    });\n  }, []);\n\n  // Panels need to deregister on unmount to avoid orphans in menu state.\n  // This is an issue when panel items are being injected via SlotFills.\n  const deregisterPanelItem = useCallback(label => {\n    // When switching selections between components injecting matching\n    // controls, e.g. both panels have a \"padding\" control, the\n    // deregistration of the first panel doesn't occur until after the\n    // registration of the next.\n    panelDispatch({\n      type: 'UNREGISTER_PANEL',\n      label\n    });\n  }, []);\n  const registerResetAllFilter = useCallback(filter => {\n    dispatchResetAllFilters({\n      type: 'REGISTER',\n      filter\n    });\n  }, []);\n  const deregisterResetAllFilter = useCallback(filter => {\n    dispatchResetAllFilters({\n      type: 'UNREGISTER',\n      filter\n    });\n  }, []);\n\n  // Updates the status of the panel\u2019s menu items. For default items the\n  // value represents whether it differs from the default and for optional\n  // items whether the item is shown.\n  const flagItemCustomization = useCallback((value, label, group = 'default') => {\n    panelDispatch({\n      type: 'UPDATE_VALUE',\n      group,\n      label,\n      value\n    });\n  }, []);\n\n  // Whether all optional menu items are hidden or not must be tracked\n  // in order to later determine if the panel display is empty and handle\n  // conditional display of a plus icon to indicate the presence of further\n  // menu items.\n  const areAllOptionalControlsHidden = useMemo(() => {\n    return isMenuItemTypeEmpty(menuItems.default) && !isMenuItemTypeEmpty(menuItems.optional) && Object.values(menuItems.optional).every(isSelected => !isSelected);\n  }, [menuItems]);\n  const cx = useCx();\n  const classes = useMemo(() => {\n    const wrapperStyle = hasInnerWrapper && styles.ToolsPanelWithInnerWrapper(DEFAULT_COLUMNS);\n    const emptyStyle = areAllOptionalControlsHidden && styles.ToolsPanelHiddenInnerWrapper;\n    return cx(styles.ToolsPanel(DEFAULT_COLUMNS), wrapperStyle, emptyStyle, className);\n  }, [areAllOptionalControlsHidden, className, cx, hasInnerWrapper]);\n\n  // Toggle the checked state of a menu item which is then used to determine\n  // display of the item within the panel.\n  const toggleItem = useCallback(label => {\n    panelDispatch({\n      type: 'TOGGLE_VALUE',\n      label\n    });\n  }, []);\n\n  // Resets display of children and executes resetAll callback if available.\n  const resetAllItems = useCallback(() => {\n    if (typeof resetAll === 'function') {\n      isResettingRef.current = true;\n      resetAll(resetAllFilters);\n    }\n\n    // Turn off display of all non-default items.\n    panelDispatch({\n      type: 'RESET_ALL'\n    });\n  }, [resetAllFilters, resetAll]);\n\n  // Assist ItemGroup styling when there are potentially hidden placeholder\n  // items by identifying first & last items that are toggled on for display.\n  const getFirstVisibleItemLabel = items => {\n    const optionalItems = menuItems.optional || {};\n    const firstItem = items.find(item => item.isShownByDefault || optionalItems[item.label]);\n    return firstItem?.label;\n  };\n  const firstDisplayedItem = getFirstVisibleItemLabel(panelItems);\n  const lastDisplayedItem = getFirstVisibleItemLabel([...panelItems].reverse());\n  const hasMenuItems = panelItems.length > 0;\n  const panelContext = useMemo(() => ({\n    areAllOptionalControlsHidden,\n    deregisterPanelItem,\n    deregisterResetAllFilter,\n    firstDisplayedItem,\n    flagItemCustomization,\n    hasMenuItems,\n    isResetting: isResettingRef.current,\n    lastDisplayedItem,\n    menuItems,\n    panelId,\n    registerPanelItem,\n    registerResetAllFilter,\n    shouldRenderPlaceholderItems,\n    __experimentalFirstVisibleItemClass,\n    __experimentalLastVisibleItemClass\n  }), [areAllOptionalControlsHidden, deregisterPanelItem, deregisterResetAllFilter, firstDisplayedItem, flagItemCustomization, lastDisplayedItem, menuItems, panelId, hasMenuItems, registerResetAllFilter, registerPanelItem, shouldRenderPlaceholderItems, __experimentalFirstVisibleItemClass, __experimentalLastVisibleItemClass]);\n  return {\n    ...otherProps,\n    headingLevel,\n    panelContext,\n    resetAllItems,\n    toggleItem,\n    className: classes\n  };\n}"],
  "mappings": "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",
  "names": []
}
