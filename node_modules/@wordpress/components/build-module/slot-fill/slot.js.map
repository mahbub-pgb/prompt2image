{
  "version": 3,
  "sources": ["../../src/slot-fill/slot.tsx"],
  "sourcesContent": ["/**\n * External dependencies\n */\n\n/**\n * WordPress dependencies\n */\nimport { useObservableValue } from '@wordpress/compose';\nimport { useContext, useLayoutEffect, useRef, Children, cloneElement, isEmptyElement } from '@wordpress/element';\n\n/**\n * Internal dependencies\n */\nimport SlotFillContext from './context';\nimport { Fragment as _Fragment, jsx as _jsx } from \"react/jsx-runtime\";\n/**\n * Whether the argument is a function.\n *\n * @param maybeFunc The argument to check.\n * @return True if the argument is a function, false otherwise.\n */\nfunction isFunction(maybeFunc) {\n  return typeof maybeFunc === 'function';\n}\nfunction addKeysToChildren(children) {\n  return Children.map(children, (child, childIndex) => {\n    if (!child || typeof child === 'string') {\n      return child;\n    }\n    let childKey = childIndex;\n    if (typeof child === 'object' && 'key' in child && child?.key) {\n      childKey = child.key;\n    }\n    return cloneElement(child, {\n      key: childKey\n    });\n  });\n}\nfunction Slot(props) {\n  var _useObservableValue;\n  const registry = useContext(SlotFillContext);\n  const instanceRef = useRef({});\n  const {\n    name,\n    children,\n    fillProps = {}\n  } = props;\n  useLayoutEffect(() => {\n    const instance = instanceRef.current;\n    registry.registerSlot(name, instance);\n    return () => registry.unregisterSlot(name, instance);\n  }, [registry, name]);\n  let fills = (_useObservableValue = useObservableValue(registry.fills, name)) !== null && _useObservableValue !== void 0 ? _useObservableValue : [];\n  const currentSlot = useObservableValue(registry.slots, name);\n\n  // Fills should only be rendered in the currently registered instance of the slot.\n  if (currentSlot !== instanceRef.current) {\n    fills = [];\n  }\n  const renderedFills = fills.map(fill => {\n    const fillChildren = isFunction(fill.children) ? fill.children(fillProps) : fill.children;\n    return addKeysToChildren(fillChildren);\n  }).filter(\n  // In some cases fills are rendered only when some conditions apply.\n  // This ensures that we only use non-empty fills when rendering, i.e.,\n  // it allows us to render wrappers only when the fills are actually present.\n  element => !isEmptyElement(element));\n  return /*#__PURE__*/_jsx(_Fragment, {\n    children: isFunction(children) ? children(renderedFills) : renderedFills\n  });\n}\nexport default Slot;"],
  "mappings": "AAOA,SAAS,0BAA0B;AACnC,SAAS,YAAY,iBAAiB,QAAQ,UAAU,cAAc,sBAAsB;AAK5F,OAAO,qBAAqB;AAC5B,SAAS,YAAY,WAAW,OAAO,YAAY;AAOnD,SAAS,WAAW,WAAW;AAC7B,SAAO,OAAO,cAAc;AAC9B;AACA,SAAS,kBAAkB,UAAU;AACnC,SAAO,SAAS,IAAI,UAAU,CAAC,OAAO,eAAe;AACnD,QAAI,CAAC,SAAS,OAAO,UAAU,UAAU;AACvC,aAAO;AAAA,IACT;AACA,QAAI,WAAW;AACf,QAAI,OAAO,UAAU,YAAY,SAAS,SAAS,OAAO,KAAK;AAC7D,iBAAW,MAAM;AAAA,IACnB;AACA,WAAO,aAAa,OAAO;AAAA,MACzB,KAAK;AAAA,IACP,CAAC;AAAA,EACH,CAAC;AACH;AACA,SAAS,KAAK,OAAO;AACnB,MAAI;AACJ,QAAM,WAAW,WAAW,eAAe;AAC3C,QAAM,cAAc,OAAO,CAAC,CAAC;AAC7B,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,YAAY,CAAC;AAAA,EACf,IAAI;AACJ,kBAAgB,MAAM;AACpB,UAAM,WAAW,YAAY;AAC7B,aAAS,aAAa,MAAM,QAAQ;AACpC,WAAO,MAAM,SAAS,eAAe,MAAM,QAAQ;AAAA,EACrD,GAAG,CAAC,UAAU,IAAI,CAAC;AACnB,MAAI,SAAS,sBAAsB,mBAAmB,SAAS,OAAO,IAAI,OAAO,QAAQ,wBAAwB,SAAS,sBAAsB,CAAC;AACjJ,QAAM,cAAc,mBAAmB,SAAS,OAAO,IAAI;AAG3D,MAAI,gBAAgB,YAAY,SAAS;AACvC,YAAQ,CAAC;AAAA,EACX;AACA,QAAM,gBAAgB,MAAM,IAAI,UAAQ;AACtC,UAAM,eAAe,WAAW,KAAK,QAAQ,IAAI,KAAK,SAAS,SAAS,IAAI,KAAK;AACjF,WAAO,kBAAkB,YAAY;AAAA,EACvC,CAAC,EAAE;AAAA;AAAA;AAAA;AAAA,IAIH,aAAW,CAAC,eAAe,OAAO;AAAA,EAAC;AACnC,SAAoB,qBAAK,WAAW;AAAA,IAClC,UAAU,WAAW,QAAQ,IAAI,SAAS,aAAa,IAAI;AAAA,EAC7D,CAAC;AACH;AACA,IAAO,eAAQ;",
  "names": []
}
