{
  "version": 3,
  "sources": ["../../src/menu/popover.tsx"],
  "sourcesContent": ["/**\n * External dependencies\n */\nimport * as Ariakit from '@ariakit/react';\n\n/**\n * WordPress dependencies\n */\nimport { useContext, useMemo, forwardRef, useCallback } from '@wordpress/element';\n\n/**\n * Internal dependencies\n */\n\nimport * as Styled from './styles';\nimport { Context } from './context';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport const Popover = forwardRef(function Popover({\n  gutter,\n  children,\n  shift,\n  modal = true,\n  ...otherProps\n}, ref) {\n  const menuContext = useContext(Context);\n\n  // Extract the side from the applied placement \u2014 useful for animations.\n  // Using `currentPlacement` instead of `placement` to make sure that we\n  // use the final computed placement (including \"flips\" etc).\n  const appliedPlacementSide = Ariakit.useStoreState(menuContext?.store, 'currentPlacement')?.split('-')[0];\n  const hideOnEscape = useCallback(event => {\n    // Pressing Escape can cause unexpected consequences (ie. exiting\n    // full screen mode on MacOs, close parent modals...).\n    event.preventDefault();\n    // Returning `true` causes the menu to hide.\n    return true;\n  }, []);\n  const computedDirection = Ariakit.useStoreState(menuContext?.store, 'rtl') ? 'rtl' : 'ltr';\n  const wrapperProps = useMemo(() => ({\n    dir: computedDirection,\n    style: {\n      direction: computedDirection\n    }\n  }), [computedDirection]);\n  if (!menuContext?.store) {\n    throw new Error('Menu.Popover can only be rendered inside a Menu component');\n  }\n  return /*#__PURE__*/_jsx(Ariakit.Menu, {\n    ...otherProps,\n    ref: ref,\n    modal: modal,\n    store: menuContext.store\n    // Root menu has an 8px distance from its trigger,\n    // otherwise 0 (which causes the submenu to slightly overlap)\n    ,\n    gutter: gutter !== null && gutter !== void 0 ? gutter : menuContext.store.parent ? 0 : 8\n    // Align nested menu by the same (but opposite) amount\n    // as the menu container's padding.\n    ,\n    shift: shift !== null && shift !== void 0 ? shift : menuContext.store.parent ? -4 : 0,\n    hideOnHoverOutside: false,\n    \"data-side\": appliedPlacementSide,\n    wrapperProps: wrapperProps,\n    hideOnEscape: hideOnEscape,\n    unmountOnHide: true,\n    render: renderProps =>\n    /*#__PURE__*/\n    // Two wrappers are needed for the entry animation, where the menu\n    // container scales with a different factor than its contents.\n    // The {...renderProps} are passed to the inner wrapper, so that the\n    // menu element is the direct parent of the menu item elements.\n    _jsx(Styled.PopoverOuterWrapper, {\n      variant: menuContext.variant,\n      children: /*#__PURE__*/_jsx(Styled.PopoverInnerWrapper, {\n        ...renderProps\n      })\n    }),\n    children: children\n  });\n});"],
  "mappings": "AAGA,YAAY,aAAa;AAKzB,SAAS,YAAY,SAAS,YAAY,mBAAmB;AAM7D,YAAY,YAAY;AACxB,SAAS,eAAe;AACxB,SAAS,OAAO,YAAY;AACrB,MAAM,UAAU,WAAW,SAASA,SAAQ;AAAA,EACjD;AAAA,EACA;AAAA,EACA;AAAA,EACA,QAAQ;AAAA,EACR,GAAG;AACL,GAAG,KAAK;AACN,QAAM,cAAc,WAAW,OAAO;AAKtC,QAAM,uBAAuB,QAAQ,cAAc,aAAa,OAAO,kBAAkB,GAAG,MAAM,GAAG,EAAE,CAAC;AACxG,QAAM,eAAe,YAAY,WAAS;AAGxC,UAAM,eAAe;AAErB,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACL,QAAM,oBAAoB,QAAQ,cAAc,aAAa,OAAO,KAAK,IAAI,QAAQ;AACrF,QAAM,eAAe,QAAQ,OAAO;AAAA,IAClC,KAAK;AAAA,IACL,OAAO;AAAA,MACL,WAAW;AAAA,IACb;AAAA,EACF,IAAI,CAAC,iBAAiB,CAAC;AACvB,MAAI,CAAC,aAAa,OAAO;AACvB,UAAM,IAAI,MAAM,2DAA2D;AAAA,EAC7E;AACA,SAAoB,qBAAK,QAAQ,MAAM;AAAA,IACrC,GAAG;AAAA,IACH;AAAA,IACA;AAAA,IACA,OAAO,YAAY;AAAA,IAInB,QAAQ,WAAW,QAAQ,WAAW,SAAS,SAAS,YAAY,MAAM,SAAS,IAAI;AAAA,IAIvF,OAAO,UAAU,QAAQ,UAAU,SAAS,QAAQ,YAAY,MAAM,SAAS,KAAK;AAAA,IACpF,oBAAoB;AAAA,IACpB,aAAa;AAAA,IACb;AAAA,IACA;AAAA,IACA,eAAe;AAAA,IACf,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA,MAMR,qBAAK,OAAO,qBAAqB;AAAA,QAC/B,SAAS,YAAY;AAAA,QACrB,UAAuB,qBAAK,OAAO,qBAAqB;AAAA,UACtD,GAAG;AAAA,QACL,CAAC;AAAA,MACH,CAAC;AAAA;AAAA,IACD;AAAA,EACF,CAAC;AACH,CAAC;",
  "names": ["Popover"]
}
