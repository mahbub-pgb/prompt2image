{
  "version": 3,
  "sources": ["../../src/tabs/tablist.tsx"],
  "sourcesContent": ["/**\n * External dependencies\n */\nimport * as Ariakit from '@ariakit/react';\nimport clsx from 'clsx';\n\n/**\n * WordPress dependencies\n */\nimport warning from '@wordpress/warning';\nimport { forwardRef, useLayoutEffect, useState } from '@wordpress/element';\nimport { useMergeRefs } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\n\nimport { useTabsContext } from './context';\nimport { StyledTabList } from './styles';\nimport { useTrackElementOffsetRect } from '../utils/element-rect';\nimport { useTrackOverflow } from './use-track-overflow';\nimport { useAnimatedOffsetRect } from '../utils/hooks/use-animated-offset-rect';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DEFAULT_SCROLL_MARGIN = 24;\n\n/**\n * Scrolls a given parent element so that a given rect is visible.\n *\n * The scroll is updated initially and whenever the rect changes.\n */\nfunction useScrollRectIntoView(parent, rect, {\n  margin = DEFAULT_SCROLL_MARGIN\n} = {}) {\n  useLayoutEffect(() => {\n    if (!parent || !rect) {\n      return;\n    }\n    const {\n      scrollLeft: parentScroll\n    } = parent;\n    const parentWidth = parent.getBoundingClientRect().width;\n    const {\n      left: childLeft,\n      width: childWidth\n    } = rect;\n    const parentRightEdge = parentScroll + parentWidth;\n    const childRightEdge = childLeft + childWidth;\n    const rightOverflow = childRightEdge + margin - parentRightEdge;\n    const leftOverflow = parentScroll - (childLeft - margin);\n    let scrollLeft = null;\n    if (leftOverflow > 0) {\n      scrollLeft = parentScroll - leftOverflow;\n    } else if (rightOverflow > 0) {\n      scrollLeft = parentScroll + rightOverflow;\n    }\n    if (scrollLeft !== null) {\n      /**\n       * The optional chaining is used here to avoid unit test failures.\n       * It can be removed when JSDOM supports `Element` scroll methods.\n       * See: https://github.com/WordPress/gutenberg/pull/66498#issuecomment-2441146096\n       */\n      parent.scroll?.({\n        left: scrollLeft\n      });\n    }\n  }, [margin, parent, rect]);\n}\nexport const TabList = forwardRef(function TabList({\n  children,\n  ...otherProps\n}, ref) {\n  var _useTabsContext;\n  const {\n    store\n  } = (_useTabsContext = useTabsContext()) !== null && _useTabsContext !== void 0 ? _useTabsContext : {};\n  const selectedId = Ariakit.useStoreState(store, 'selectedId');\n  const activeId = Ariakit.useStoreState(store, 'activeId');\n  const selectOnMove = Ariakit.useStoreState(store, 'selectOnMove');\n  const items = Ariakit.useStoreState(store, 'items');\n  const [parent, setParent] = useState();\n  const refs = useMergeRefs([ref, setParent]);\n  const selectedItem = store?.item(selectedId);\n  const renderedItems = Ariakit.useStoreState(store, 'renderedItems');\n  const selectedItemIndex = renderedItems && selectedItem ? renderedItems.indexOf(selectedItem) : -1;\n  // Use selectedItemIndex as a dependency to force recalculation when the\n  // selected item index changes (elements are swapped / added / removed).\n  const selectedRect = useTrackElementOffsetRect(selectedItem?.element, [selectedItemIndex]);\n\n  // Track overflow to show scroll hints.\n  const overflow = useTrackOverflow(parent, {\n    first: items?.at(0)?.element,\n    last: items?.at(-1)?.element\n  });\n\n  // Size, position, and animate the indicator.\n  useAnimatedOffsetRect(parent, selectedRect, {\n    prefix: 'selected',\n    dataAttribute: 'indicator-animated',\n    transitionEndFilter: event => event.pseudoElement === '::before',\n    roundRect: true\n  });\n\n  // Make sure selected tab is scrolled into view.\n  useScrollRectIntoView(parent, selectedRect);\n  const onBlur = () => {\n    if (!selectOnMove) {\n      return;\n    }\n\n    // When automatic tab selection is on, make sure that the active tab is up\n    // to date with the selected tab when leaving the tablist. This makes sure\n    // that the selected tab will receive keyboard focus when tabbing back into\n    // the tablist.\n    if (selectedId !== activeId) {\n      store?.setActiveId(selectedId);\n    }\n  };\n  if (!store) {\n    globalThis.SCRIPT_DEBUG === true ? warning('`Tabs.TabList` must be wrapped in a `Tabs` component.') : void 0;\n    return null;\n  }\n  return /*#__PURE__*/_jsx(StyledTabList, {\n    ref: refs,\n    store: store,\n    render: props => {\n      var _props$tabIndex;\n      return /*#__PURE__*/_jsx(\"div\", {\n        ...props,\n        // Fallback to -1 to prevent browsers from making the tablist\n        // tabbable when it is a scrolling container.\n        tabIndex: (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : -1\n      });\n    },\n    onBlur: onBlur,\n    \"data-select-on-move\": selectOnMove ? 'true' : 'false',\n    ...otherProps,\n    className: clsx(overflow.first && 'is-overflowing-first', overflow.last && 'is-overflowing-last', otherProps.className),\n    children: children\n  });\n});"],
  "mappings": "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",
  "names": ["TabList", "warning", "_jsx", "clsx"]
}
