{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\nimport './matchers';\nimport supportedMatchers from './supported-matchers';\nimport type { ExtendedMock } from './types';\n\n/**\n * Sets spy on the console object's method to make it possible to fail test when method called without assertion.\n *\n * @param args\n */\nconst setConsoleMethodSpy = ( args: [ string, string ] ) => {\n\tconst [ methodName, matcherName ] = args;\n\tconst spy = jest\n\t\t.spyOn( console, methodName as 'error' | 'info' | 'log' | 'warn' )\n\t\t.mockName( `console.${ methodName }` ) as ExtendedMock;\n\n\t/**\n\t * Resets the spy to its initial state.\n\t */\n\tfunction resetSpy() {\n\t\tspy.mockReset();\n\t\tspy.assertionsNumber = 0;\n\t}\n\n\t/**\n\t * Verifies that the spy has only been called if expected.\n\t */\n\tfunction assertExpectedCalls() {\n\t\tif ( spy.assertionsNumber === 0 && spy.mock.calls.length > 0 ) {\n\t\t\texpect( console ).not[ matcherName ]();\n\t\t}\n\t}\n\n\tbeforeAll( resetSpy );\n\n\tbeforeEach( () => {\n\t\tassertExpectedCalls();\n\t\tresetSpy();\n\t} );\n\n\tafterEach( assertExpectedCalls );\n};\n\nObject.entries( supportedMatchers ).forEach( setConsoleMethodSpy );\n"],
  "mappings": "AAGA,OAAO;AACP,OAAO,uBAAuB;AAQ9B,MAAM,sBAAsB,CAAE,SAA8B;AAC3D,QAAM,CAAE,YAAY,WAAY,IAAI;AACpC,QAAM,MAAM,KACV,MAAO,SAAS,UAAgD,EAChE,SAAU,WAAY,UAAW,EAAG;AAKtC,WAAS,WAAW;AACnB,QAAI,UAAU;AACd,QAAI,mBAAmB;AAAA,EACxB;AAKA,WAAS,sBAAsB;AAC9B,QAAK,IAAI,qBAAqB,KAAK,IAAI,KAAK,MAAM,SAAS,GAAI;AAC9D,aAAQ,OAAQ,EAAE,IAAK,WAAY,EAAE;AAAA,IACtC;AAAA,EACD;AAEA,YAAW,QAAS;AAEpB,aAAY,MAAM;AACjB,wBAAoB;AACpB,aAAS;AAAA,EACV,CAAE;AAEF,YAAW,mBAAoB;AAChC;AAEA,OAAO,QAAS,iBAAkB,EAAE,QAAS,mBAAoB;",
  "names": []
}
