{
  "version": 3,
  "sources": ["../src/objects.ts"],
  "sourcesContent": ["/**\n * Internal dependencies\n */\nimport type { ComparableObject } from '.';\n\n/**\n * Returns true if the two objects are shallow equal, or false otherwise.\n *\n * @param a First object to compare.\n * @param b Second object to compare.\n *\n * @return Whether the two objects are shallow equal.\n */\nexport default function isShallowEqualObjects(\n\ta: ComparableObject,\n\tb: ComparableObject\n): boolean {\n\tif ( a === b ) {\n\t\treturn true;\n\t}\n\n\tconst aKeys = Object.keys( a );\n\tconst bKeys = Object.keys( b );\n\n\tif ( aKeys.length !== bKeys.length ) {\n\t\treturn false;\n\t}\n\n\tlet i = 0;\n\n\twhile ( i < aKeys.length ) {\n\t\tconst key = aKeys[ i ];\n\t\tconst aValue = a[ key ];\n\n\t\tif (\n\t\t\t// In iterating only the keys of the first object after verifying\n\t\t\t// equal lengths, account for the case that an explicit `undefined`\n\t\t\t// value in the first is implicitly undefined in the second.\n\t\t\t//\n\t\t\t// Example: isShallowEqualObjects( { a: undefined }, { b: 5 } )\n\t\t\t( aValue === undefined && ! b.hasOwnProperty( key ) ) ||\n\t\t\taValue !== b[ key ]\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn true;\n}\n"],
  "mappings": "AAae,SAAR,sBACN,GACA,GACU;AACV,MAAK,MAAM,GAAI;AACd,WAAO;AAAA,EACR;AAEA,QAAM,QAAQ,OAAO,KAAM,CAAE;AAC7B,QAAM,QAAQ,OAAO,KAAM,CAAE;AAE7B,MAAK,MAAM,WAAW,MAAM,QAAS;AACpC,WAAO;AAAA,EACR;AAEA,MAAI,IAAI;AAER,SAAQ,IAAI,MAAM,QAAS;AAC1B,UAAM,MAAM,MAAO,CAAE;AACrB,UAAM,SAAS,EAAG,GAAI;AAEtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMG,WAAW,UAAa,CAAE,EAAE,eAAgB,GAAI,KAClD,WAAW,EAAG,GAAI;AAAA,MACjB;AACD,aAAO;AAAA,IACR;AAEA;AAAA,EACD;AAEA,SAAO;AACR;",
  "names": []
}
